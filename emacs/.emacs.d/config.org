#+STARTUP: showeverything
* Emacs configuration
** Themes
*** Gruvbox theme
    The Gruvbox theme has everything that I love about Emacs, it is the theme that I have been working with for the longest time and I couldn't be happier about it. The reason I have the solarized theme under it is because I'm trying out a function to change the theme depending on the hour of the day.
    #+begin_src emacs-lisp
      (use-package gruvbox-theme
        :straight t
        :config (load-theme 'gruvbox-dark-soft t))
    #+end_src

*** Solarized theme
    This is the second theme in my book. I really like the solarized theme, but Gruvbox stills wins it. The reason I have it here is because of its light theme.
    #+begin_src emacs-lisp :tangle no
      (use-package solarized-theme
        :straight t)
    #+end_src

** Better defaults
*** Keep emacs clean
    This is the section created with the intention of make emacs create the files needed, but keep
    the directories clean, saving the backup files in set locations.

**** No-littering
     No littering is a package which is used with intention of keeping the generated
     files by emacs to a minimum, by changing the path where all of the files are stored,
     being by default the current directory.
     #+begin_src emacs-lisp
       (use-package no-littering
         :straight t)
     #+end_src
**** Backup files
     Files created with the tilde extension, used to track changes to files, being able to 
     recover them on system crash.
     #+begin_src emacs-lisp
       (setq backup-directory-alist `(("." . ,(no-littering-expand-var-file-name "backups/"))))
     #+end_src

**** Auto save files
     Files created when you haven't saved a file yet.
     #+begin_src emacs-lisp
       (setq auto-save-list-file-prefix (no-littering-expand-var-file-name "auto-saves/sessions/")
             auto-save-file-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-saves/") t)))
       (use-package emacs
         :init
         (defun xah/save-all-unsaved ()
           "Save all unsaved files. no ask."
           (interactive)
           (save-some-buffers t))
         :config
         (add-function :after after-focus-change-function #'xah/save-all-unsaved))
     #+end_src

**** Lockfiles and versions
     configuration of lockfiles and version control for files,
     the intention this modification is the clean workspace directories.
     #+begin_src emacs-lisp
       (setq
        create-lockfiles nil
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)
     #+end_src
*** Default bindings
    There are some awful keybindings that Emacs binds by default. These better defaults try to give a little more user-friendly keybindings, while maintaining the original Emacs essence.
    #+begin_src emacs-lisp
      (use-package dabbrev
        ;; Swap M-/ and C-M-/
        :bind (("M-/" . dabbrev-completion)
               ("C-M-/" . dabbrev-expand)))
    #+end_src

    
*** Setting faces easily
    Found the face-spec-set, which is the easiest way to configure the faces for especific
    modes, specially using use-package. The code is from the [[https://se30.xyz/conf.html][Alexm website]].
    #+begin_src emacs-lisp
      (defun alexm/set-faces-by-spec (&rest specs)
        "Maps SPECS through face-spec-set."
        (mapc #'(lambda (f) (apply #'face-spec-set f)) specs))
    #+end_src

*** Try
    Package that allows to try emacs packages without installing them.
    What it really does is installing the files in a temp directory and
    removing them later.

    #+BEGIN_SRC emacs-lisp
      (use-package try
        :straight t)
    #+END_SRC

*** Delimiters
**** smart-parens
     Smart-parens is a package that improves on the previous package,
     now deprecated: autopair. Smart-parens has the plus of being maintained,
     considering that they usually merge pull requests and responde to issues.

     #+begin_src emacs-lisp
       (use-package smartparens
         :straight t
         :hook (prog-mode . smartparens-mode)
         :config (require 'smartparens-config))
     #+end_src

**** rainbow-delimiters
     In order to be able to differentiate the parenthesis in all programming
     modes, rainbow-delimiters considers different faces from your current theme
     and adds the same face to the matching parens.

     #+begin_src emacs-lisp
       (use-package rainbow-delimiters
         :straight t
         :hook (prog-mode . rainbow-delimiters-mode)
         :config
         (alexm/set-faces-by-spec
          '(rainbow-delimiters-base-error-face
            ((t (:foreground "#fc0303" :inherit nil)))))
         (alexm/set-faces-by-spec
          '(rainbow-delimiters-mismatched-face
            ((t (:foreground "#fc0303" :inherit nil)))))
         (alexm/set-faces-by-spec
          '(rainbow-delimiters-unmatched-face
            ((t (:foreground "#fc0303" :inherit nil))))))
     #+end_src

*** Modeline
**** Doom-modeline
     #+BEGIN_SRC emacs-lisp
       (use-package doom-modeline
         :straight t
         :config
         (progn
           (doom-modeline-mode 1)
           (setq doom-modeline-project-detection 'project)
           (setq doom-modeline-window-width-limit fill-column)))
       (defvar doom-modeline-icon (display-graphic-p)
         "Whether show `all-the-icons' or not.

               Non-nil to show the icons in mode-line.
               The icons may not be showed correctly in terminal and on Windows."
         )
       (setq doom-modeline-icon t)
       (defface egoge-display-time
         '((((type x w32 mac))
            ;; #060525 is the background colour of my default face.
            (:foreground "#fcfcfc" :inherit bold))
           (((type tty))
            (:foreground "blue")))
         "Face used to display the time in the mode line.")
       (setq display-time-string-forms
             '((propertize (concat " " 24-hours ":" minutes " ")
                           'face 'egoge-display-time)))
       (display-time-mode 1)
       (display-time-update)
     #+END_SRC

**** All-the-icons
     #+BEGIN_SRC emacs-lisp
       (use-package all-the-icons
         :straight t)
     #+END_SRC

*** Commenting
**** Smart comments
     When at the end of the line, creates a end-line comment.
     When at the beginning or middle of the line, comments line.
     When pointing at region, comments full region.

     #+BEGIN_SRC emacs-lisp
       (use-package smart-comment
         :straight t
         :bind ("M-;" . smart-comment))
     #+END_SRC

**** Copy and comment
     Custom function created with the intention of using the commented
     lines in order to make sure that we are not forgetting any additional
     code. I used to have a package that did all of the comment stuff, but
     it seems to have been deprecated.
     #+begin_src emacs-lisp
       (defun dr/copy-and-comment-region (beg end &optional arg)
         "Duplicate the region and comment-out the copied text.
         See `comment-region' for behavior of a prefix arg."
         (interactive "r\nP")
         (copy-region-as-kill beg end)
         (goto-char end)
         (yank)
         (comment-region beg end arg))
       (global-set-key (kbd "C-M-;") 'dr/copy-and-comment-region)
     #+end_src

*** Buffers
**** Bufler
     Better bufler list, creating projects and groups.
     #+begin_src emacs-lisp
       (use-package bufler
         :straight t
         :config (defhydra+ hydra:bufler ()
                   ("o" #'delete-other-windows "Full screen"))
         :bind (:map bufler-list-mode-map
                     ("o" . delete-other-windows)))
     #+end_src


     Function to make bufler buffer full-screen.
     #+BEGIN_SRC emacs-lisp
       (defun bufler-one-window (&optional force-refresh)
         (interactive "P")
         (bufler-list)
         (delete-other-windows)
         )
       (global-set-key (kbd "C-x C-b") 'bufler)
     #+END_SRC

*** Directories
**** Dired
     Dired is the "package" that gives us all the functionality
     to a dired buffer which in essence is the same as the output
     of ls. Adding an especial command for dired-up-directory as 
     the default keybinding is ^ which I find difficult to reach.

     #+begin_src emacs-lisp
       (use-package dired
         :bind (:map dired-mode-map 
                     ("b" . dired-up-directory)
                     ("M-s f" . affe-find)))
     #+end_src

**** Directories first on dired.
     #+BEGIN_SRC emacs-lisp
       (setq dired-listing-switches "-aBhl  --group-directories-first")
     #+END_SRC

**** Backup directory
     #+BEGIN_SRC emacs-lisp
       (setq backup-directory-alist '(("" . "~/.emacs.d/backup")))
     #+END_SRC

*** Help
    The default emacs help buffers could use some tweaking, and the Helpful package is there to assist. It provides better formatting and links for help buffers, and defines different functions to limit the disruption effect in your emacs configuration.
    #+begin_src emacs-lisp
      (use-package helpful
        :straight t
        :init
        (global-set-key (kbd "C-h f") #'helpful-function)
        (global-set-key (kbd "C-h v") #'helpful-variable)
        (global-set-key (kbd "C-h c") #'helpful-key))
#+end_src

    
*** Latex
**** :warning: TESTING: lsp-latex
     LaTeX has its own lsp server: texlab. I have added it here to check whether I'm interested in keeping it or keep going with latex. I added the TESTING flag to let the possible outside user know.
     #+begin_src emacs-lisp
       (use-package lsp-latex
         :straight t)
     #+end_src

    
    Adding reference connection made easier with reftex.
    #+BEGIN_SRC emacs-lisp
      (use-package reftex
        :straight t
        :defer t
        :config
        (setq reftex-cite-prompt-optional-args t))
    #+END_SRC

    Adding autodictionary in order to get completion on the words
    that have been miss-typed.
    #+BEGIN_SRC emacs-lisp
      (use-package auto-dictionary
        :straight t
        :init(add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode 1))))
    #+END_SRC

    Adding general configuration for tex files and latex-mode better defaults.
    #+BEGIN_SRC emacs-lisp
      (use-package tex
        :straight auctex
        :mode ("\\.tex\\'" . latex-mode)
        :config (progn
                  (setq TeX-source-correlate-mode t)
                  (setq TeX-source-correlate-method 'synctex)
                  (setq TeX-auto-save t)
                  (setq TeX-parse-self t)
                  (setq-default TeX-master nil)
                  (setq reftex-plug-into-AUCTeX t)
                  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
                        TeX-source-correlate-start-server t)
                  ;; Update PDF buffers after successful LaTeX runs
                  (add-hook 'TeX-after-compilation-finished-functions
                            #'TeX-revert-document-buffer)
                  (add-hook 'LaTeX-mode-hook
                            (lambda ()
                              (reftex-mode t)
                              (flyspell-mode t)))
                  ))
    #+END_SRC

    Removing the mark keybindings on latex buffers, which are
    normally bound to the flyspell word correction keys.
    #+begin_src emacs-lisp
      (use-package flyspell
        :bind (:map flyspell-mode-map (("C-." . nil)
                                       ("C-," . nil))))
    #+end_src

*** Appearence
**** Cursor display
     Bar cursor instead of rectangle default.
     #+BEGIN_SRC emacs-lisp
       (setq-default cursor-type 'bar)
     #+END_SRC

**** Yes/No with y/n
     #+BEGIN_SRC emacs-lisp
       (fset 'yes-or-no-p 'y-or-n-p)
     #+END_SRC

**** Splash screen and startup message
     #+BEGIN_SRC emacs-lisp
       (setq inhibit-startup-message t)
     #+END_SRC

**** Line numeration on left side
     #+BEGIN_SRC emacs-lisp
       (global-linum-mode t)
       (put 'erase-buffer 'disabled nil)
     #+END_SRC

**** New lines
     Adding newline at the end of the file.
     #+BEGIN_SRC emacs-lisp
       (setq next-line-add-newlines t)    
     #+END_SRC

**** Sounds
     Disabling beep sound.
     #+BEGIN_SRC emacs-lisp
       (setq visible-bell 1)
     #+END_SRC

**** Toolbar
     Disabling toolbar.
     #+BEGIN_SRC emacs-lisp
       (tool-bar-mode -1)
     #+END_SRC

**** Scrollbar
     Removing scrollbar.
     #+BEGIN_SRC emacs-lisp
       (when (fboundp 'set-scroll-bar-mode)
         (set-scroll-bar-mode nil))
       (defun qk/disable-scroll-bars (frame)
         (modify-frame-parameters frame
                                  '((vertical-scroll-bars . nil)
                                    (horizontal-scroll-bars . nil))))
       (add-hook 'after-make-frame-functions 'qk/disable-scroll-bars)
     #+END_SRC

**** Menubar
     Disabling the menubar, prior to tab-mode-line configuration.
     #+BEGIN_SRC emacs-lisp
       (menu-bar-mode -1)
     #+END_SRC

**** Fonts
     #+BEGIN_SRC emacs-lisp
       (setq default-frame-alist '((font . "Ubuntu Mono-13")))
     #+END_SRC

*** Indentation
    Indentation to 4 spaces instead of tab.
    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
      (setq-default tab-width 4)
      ;; (setq indent-line-function 'insert-tab)
    #+END_SRC

*** Markdown
    Markdown configuration, which I use specially often when editing README files
    on Github. The are some interesting options like the change of the markdown-command
    to pandoc which is way better at compiling html5. After that, we are using
    impatient-mode which is a package that allows for life preview of the file as you are
    editing it, which is amazing. Last but not least, we are configuring a markdown filter
    in order to get the Github look when "markdowning". The configuration has be harvested
    from the [[https://blog.bitsandbobs.net/blog/emacs-markdown-live-preview/][bits and bobs blog post.]]

    The second markdown function is from this link: [[https://stackoverflow.com/questions/36183071/how-can-i-preview-markdown-in-emacs-in-real-time/41288851#41288851][stack overflow markdown link]].
    #+BEGIN_SRC emacs-lisp
      (use-package simple-httpd
        :straight t
        :custom
        (httpd-port 7070)
        (httpd-host (system-name)))

      (use-package impatient-mode
        :straight t
        :commands impatient-mode)

      (use-package markdown-mode
        :straight nil
        :mode ("\\.md\\'" . gfm-mode)
        :commands (markdown-mode gfm-mode)
        :custom (markdown-command "pandoc -t html5")
        :bind ("C-c r" . bb/markdown-preview)
        :init
        (add-hook 'markdown-mode-hook #'toc-org-mode)
        (add-hook 'markdown-mode-hook #'visual-line-mode)
        (defun bb/markdown-filter (buffer)
          (princ
           (with-temp-buffer
             (let ((tmp (buffer-name)))
               (set-buffer buffer)
               (set-buffer (markdown tmp))
               (format "<!DOCTYPE html><html><title>Markdown preview</title><link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css\"/>
                <body><article class=\"markdown-body\" style=\"box-sizing: border-box;min-width: 200px;max-width: 980px;margin: 0 auto;padding: 45px;\">%s</article></body></html>" (buffer-string))))
           (current-buffer)))
        (defun eh/markdown-html (buffer)
          (princ (with-current-buffer buffer
                   (format "<!DOCTYPE html><html><title>Impatient Markdown</title><xmp theme=\"united\" style=\"display:none;\"> %s  </xmp><script src=\"http://strapdownjs.com/v/0.2/strapdown.js\"></script></html>" (buffer-substring-no-properties (point-min) (point-max))))
                 (current-buffer)))
        (defun bb/markdown-preview ()
          "Preview markdown."
          (interactive)
          (unless (process-status "httpd")
            (httpd-start))
          (impatient-mode)
          (imp-set-user-filter 'eh/markdown-html)
          (imp-visit-buffer)))
    #+END_SRC

*** Mark commands
    Adding better defaults to the mark commands, as I find cumbersome to remove the
    region everytime I want to access the mark functionality.

    #+BEGIN_SRC emacs-lisp
      (defun push-mark-no-activate ()
        "Pushes `point' to `mark-ring' and does not activate the region
         Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
        (interactive)
        (push-mark (point) t nil)
        (message "Pushed mark to ring"))

      (defun jump-to-mark ()
        "Jumps to the local mark, respecting the `mark-ring' order.
        This is the same as using \\[set-mark-command] with the prefix argument."
        (interactive)
        (set-mark-command 1))

      (defun exchange-point-and-mark-no-activate ()
        "Identical to \\[exchange-point-and-mark] but will not activate the region."
        (interactive)
        (exchange-point-and-mark)
        (deactivate-mark nil))

      (global-set-key (kbd "C-.") 'push-mark-no-activate)
      (global-set-key (kbd "C-,") 'jump-to-mark)
      (define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
    #+END_SRC

*** Window switching
    I'm trying ace-window in order to allow faster window switching, when working with
    multiple buffers in the same frame. Disabling also the undo command, trying to get
    used to C-/
    #+BEGIN_SRC emacs-lisp
      (global-unset-key (kbd "C-x o"))
      (global-unset-key (kbd "C-x u"))
      (use-package ace-window
        :straight t
        :config 
        (global-set-key (kbd "M-o") 'ace-window)
        :custom(
                (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
                (aw-background nil)))
    #+END_SRC

*** Fill column
    #+begin_src emacs-lisp
      (setq-default fill-column 80)
    #+end_src

*** Auto indent
    #+BEGIN_SRC emacs-lisp
      (define-key global-map (kbd "RET") 'newline-and-indent)
    #+END_SRC

*** pdf tools
    pdf tools so that pages are created on demand instead of preloading the entire file, which
    may freeze emacs. Also adding the hook in order to autorevert the pdf buffer when compiling
    with auctex.
    #+BEGIN_SRC emacs-lisp
      (use-package pdf-tools
        :straight t
        :config (pdf-tools-install)
        (setq-default pdf-view-display-size 'fit-page)
        (setq pdf-annot-activate-created-annotations t)
        (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
        (define-key pdf-view-mode-map (kbd "C-r") 'isearch-backward)
        (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
        (add-hook 'pdf-view-mode-hook (lambda ()
                                        (linum-mode -1))))
    #+END_SRC

*** Which key
    Which key is the pinnacle of keybinding packages, with
    a helpful minibuffer that states the keybindings 
    available for a certain prefix you start typing.
    #+begin_src emacs-lisp
      (use-package which-key
        :straight t
        :custom
        ((which-key-show-early-on-C-h t)
         (which-key-idle-delay .5)
         (which-key-popup-type 'minibuffer))
        :config (which-key-mode))
    #+end_src

*** Ripgrep
    Adding ripgrep configuration to be able to access the functionality from emacs.
    #+begin_src emacs-lisp
      (use-package rg
        :straight t
        :config (rg-enable-default-bindings))
    #+end_src

*** Flyspelling
    Flyspelling is a process that checks the current buffer and highlights all
    the words that have been misspelled. This is key to good spelling in formal
    texts as well as blog post, or note making.
    #+begin_src emacs-lisp
      (defun fd-switch-dictionary()
        (interactive)
        (let* ((dic ispell-current-dictionary)
               (change (if (string= dic "english") "spanish" "english")))
          (ispell-change-dictionary change)
          (message "Dictionary switched from %s to %s" dic change)
          ))
      (defun flyspell-buffer-after-pdict-save (&rest _)
        (flyspell-buffer))

      (advice-add 'ispell-pdict-save :after #'flyspell-buffer-after-pdict-save)
    #+end_src

*** Syncing .profile env variables
    Emacs daemon doesn't seem to look for environment variables in the
    usual places like .profile and such. Installing the package
    exec-path-from-shell, we make sure that those important config files
    are loaded.

    :warning: WARNING: The configuration of the exec-path-from-shell-initialize from shell should be in the init.el file, which is run before tangling this whole org file. I'm just adding this for completion of the configuration.
    #+begin_src emacs-lisp :tangle no
      (use-package exec-path-from-shell
        :straight t
        :custom (exec-path-from-shell-arguments '("-l"))
        :init 
        (when (daemonp)
          (exec-path-from-shell-initialize))
        (when (memq window-system '(mac ns x))
          (exec-path-from-shell-initialize)))
    #+end_src

*** Special characters
    There are some writing characters that are used in org-mode when exporting,
    but when trying to check the file's html, the -- is exported as two individual
    dashes, instead of the em-dash.
    #+begin_src emacs-lisp
      (defun help/real-insert (char)
        (cl-flet ((do-insert
                   () (if (bound-and-true-p org-mode)
                          (org-self-insert-command 1)
                        (self-insert-command 1))))
          (setq last-command-event char)
          (do-insert)))
      (defun help/insert-em-dash ()
        "Insert a EM-DASH.
      - \"best limited to two appearances per sentence\"
      - \"can be used in place of commas to enhance readability.
         Note, however, that dashes are always more emphatic than
         commas\"
      - \"can replace a pair of parentheses. Dashes are considered
         less formal than parentheses; they are also more intrusive.
         If you want to draw attention to the parenthetical content,
         use dashes. If you want to include the parenthetical content
         more subtly, use parentheses.\"
        - \"Note that when dashes are used in place of parentheses,
           surrounding punctuation should be omitted.\"
      - \"can be used in place of a colon when you want to emphasize
         the conclusion of your sentence. The dash is less formal than
         the colon.\"
      - \"Two em dashes can be used to indicate missing portions of a
         word, whether unknown or intentionally omitted.\"
        - \"When an entire word is missing, either two or three em
           dashes can be used. Whichever length you choose, use it
           consistently throughout your document. Surrounding punctuation
           should be placed as usual.\"
      - \"The em dash is typically used without spaces on either side,
         and that is the style used in this guide. Most newspapers,
         however, set the em dash off with a single space on each side.\"
      Source: URL `https://www.thepunctuationguide.com/em-dash.html'"
        (interactive)
        (help/real-insert ?—))
      (defun help/insert-en-dash ()
        "Insert a EN-DASH.
      - \"is used to represent a span or range of numbers, dates,
         or time. There should be no space between the en dash and
         the adjacent material. Depending on the context, the en
         dash is read as “to” or “through.”\"
        - \"If you introduce a span or range with words such as
           'from' or 'between', do not use the en dash.\"
      - \"is used to report scores or results of contests.\"
      - \"an also be used between words to represent conflict,
         connection, or direction.\"
      - \"When a compound adjective is formed with an element that
         is itself an open compound or hyphenated compound, some
         writers replace the customary hyphen with an en dash. This
         is an aesthetic choice more than anything.
      Source: URL `https://www.thepunctuationguide.com/en-dash.html'"
        (interactive)
        (help/real-insert ?–))
      (defun help/insert-hyphen ()
        "Insert a HYPHEN
      - \"For most writers, the hyphen’s primary function is the
         formation of certain compound terms. The hyphen is also
         used for word division [in typesetting].
      - \"Compound terms are those that consist of more than one
         word but represent a single item or idea.\"
      Source: URL `https://www.thepunctuationguide.com/hyphen.html'"
        (interactive)
        (help/real-insert ?-))

    #+end_src

*** Browse-url
    Browse url is the package that controls the information that is passed to the browser when forwarded from emacs. I find that cookies are important when accessing chrome, might need to check again if I can select to save cookies only for Chrome browsing.

    #+begin_src emacs-lisp
      (use-package browse-url
        :straight nil
        :custom
        (url-cookie-file (no-littering-expand-var-file-name "cookies/cookies")))
    #+end_src

*** Whole-line-or-region
    Emacs doesn't have a by default command to get the whole region without going to the beginning of the line and marking the rest of the line or pressing C-S-backspace to remove the whole line.

    Whole-line-or-region implementes some changes to add the mentioned funcionality. Using the remapped C-w and M-w (cut and copy) without a region selected with select the whole line.
    #+begin_src emacs-lisp
      (use-package whole-line-or-region
        :straight t
        :config (whole-line-or-region-global-mode))
    #+end_src

** Completion framework
*** Modular completion
    Instead of having an abstracted and heavy completion framework, I find that configuring your own makes the process simpler and lighter, focusing on the information that you really need in your configuration, removing all additional commands.

**** Vertico
     Vertico provides a minimalistic vertical completion UI, which is based on the default completion system. By reusing the default system, Vertico achieves full compatibility with built-in Emacs commands and completion tables. Vertico is pretty bare-bone and comes with only a minimal set of commands. The code base is small (~500 lines of code without whitespace and comments). Additional enhancements can be installed separately via complementary packages.
     #+begin_src emacs-lisp
       (use-package vertico
         :straight t
         :init (vertico-mode)
         :custom (vertico-cycle t))
     #+end_src

**** Orderless
     Orderless is one of the same emacs packages that works modularly, using the basic emacs API. This package provides an orderless completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order. Each component can match in any one of several ways: literally, as a regexp, as an initialism, in the flex style, or as multiple word prefixes. By default, regexp and literal matches are enabled.
     #+begin_src emacs-lisp
       (use-package orderless
         :straight t
         :init
         (setq completion-styles '(orderless)
               completion-category-defaults nil
               completion-category-overrides '((file (styles . (partial-completion))))))
     #+end_src

**** Savehist
     Savehist is a built in package thar persistes the completion candidates through Emacs restarts. Vertico then can sort by history position.
     #+begin_src emacs-lisp
       (use-package savehist
         :init
         (savehist-mode))
     #+end_src

**** Recentf-mode
     Recentf-mode needs to be enabled in order to save the history of the files and use them later as virtual buffers. This is a great package (which is already built-in) combined with savehist, as savehist saves the completion candidates but not the files on which the candidates are.
     #+begin_src emacs-lisp
       (use-package recentf
         :init (recentf-mode))
     #+end_src
     
**** Additional completion configuration
     Adding a prompt indicator that the completing-read-multiple command is enabled. The other configuration is enabling recursive minibuffers. I also disabled the cursor in the minibuffer prompt, avoid clicking by accident.
     #+begin_src emacs-lisp
       (use-package emacs
         :init
         ;; Add prompt indicator to `completing-read-multiple'.
         (defun crm-indicator (args)
           (cons (concat "[CRM] " (car args)) (cdr args)))
         (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

         ;; Do not allow the cursor in the minibuffer prompt
         (setq minibuffer-prompt-properties
               '(read-only t cursor-intangible t face minibuffer-prompt))
         (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

         ;; Enable recursive minibuffers
         (setq enable-recursive-minibuffers t))
     #+end_src

**** Marginalia
     Marginalia are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations placed at the margin of the minibuffer for your completion candidates. Marginalia can only add annotations to be displayed with the completion candidates. It cannot modify the appearance of the candidates themselves, which are shown as supplied by the original commands.
     #+begin_src emacs-lisp
       (use-package marginalia
         :straight t
         :init (marginalia-mode))
     #+end_src

**** Consult
     Consult provides various practical commands based on the Emacs completion function completing-read, which allows to quickly select an item from a list of candidates with completion. Consult offers in particular an advanced buffer switching command consult-buffer to switch between buffers and recently opened files. Multiple search commands are provided, an asynchronous consult-grep and consult-ripgrep, and consult-line, which resembles Swiper. Some of the Consult commands are enhanced versions of built-in Emacs commands. For example the command consult-imenu presents a flat list of the Imenu with live preview and narrowing support.
     #+begin_src emacs-lisp
       (defun consult-fd (&optional dir initial)
         (interactive "P")
         (let ((consult-find-command "fdfind --color=never --full-path ARG OPTS"))
           (consult-find dir initial)))

       (use-package consult
         ;; Replace bindings. Lazily loaded due by `use-package'.
         :straight t
         :bind (;; C-c bindings (mode-specific-map)
                ("C-c h" . consult-history)
                ("C-c b" . consult-bookmark)
                ("C-c k" . consult-kmacro)
                ;; C-x bindings (ctl-x-map)
                ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
                ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
                ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
                ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
                ;; Custom M-# bindings for fast register access
                ("M-#" . consult-register-load)
                ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
                ("C-M-#" . consult-register)
                ;; Other custom bindings
                ("M-y" . consult-yank-pop)                ;; orig. yank-pop
                ("<help> a" . consult-apropos)            ;; orig. apropos-command
                ;; M-g bindings (goto-map)
                ("M-g e" . consult-compile-error)
                ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
                ("M-g g" . consult-goto-line)             ;; orig. goto-line
                ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
                ("M-g o" . consult-outline)
                ("M-g m" . consult-mark)
                ("M-g k" . consult-global-mark)
                ("M-g i" . consult-imenu)
                ("M-g I" . consult-project-imenu)
                ;; M-s bindings (search-map)
                ("M-s f" . consult-fd) ;; Changed on the `affe' configuration.
                ("M-s L" . consult-locate)
                ("M-s g" . consult-grep) ;; Changed on the `affe' configuration.
                ("M-s G" . consult-git-grep)
                ("M-s r" . consult-ripgrep)
                ("M-s l" . consult-line)
                ("M-s m" . consult-multi-occur)
                ("M-s k" . consult-keep-lines)
                ("M-s u" . consult-focus-lines)
                ;; Isearch integration
                ("M-s e" . consult-isearch)
                :map isearch-mode-map
                ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
                ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
                ("M-s l" . consult-line)
                :map global-map
                ("C-s" . consult-line)
                ("C-r" . consult-line))

         ;; The :init configuration is always executed (Not lazy)
         :init
         (setq register-preview-delay 0
               register-preview-function #'consult-register-format)
         (advice-add #'register-preview :override #'consult-register-window)
         ;; Use Consult to select xref locations with preview
         (setq xref-show-xrefs-function #'consult-xref
               xref-show-definitions-function #'consult-xref)
         :config
         (setq consult-narrow-key "<"))
     #+end_src

***** Consult-projectile
      Consult-projectile is a package that is still in development, adding this here only means I'm interested in having something of the sort. I might need to do a more in-depth search a few weeks forward.
      #+begin_src emacs-lisp
        (use-package consult-projectile
          :straight (consult-projectile :type git :host gitlab :repo "OlMon/consult-projectile")
          :bind ("C-c p" . consult-projectile))
      #+end_src

**** Embark
     This package provides a sort of right-click contextual menu for Emacs, accessed through the embark-act command (which you should bind to a convenient key), offering you relevant actions to use on a target determined by the context:

     - In the minibuffer, the target is the current best completion candidate.
     - In the *Completions* buffer the target is the completion at point.
     - In a regular buffer, the target is the region if active, or else the file, symbol or URL at point.
     #+begin_src emacs-lisp
       (use-package embark
         :straight t
         :bind
         (("C-M-y" . embark-act)       ;; pick some comfortable binding
          ("C-h B" . embark-bindings) ;; alternative for `describe-bindings'
          :map embark-file-map
          ("s" . embark-magit-status)
          :map minibuffer-local-map
          ("M-o" . embark-act))
         :init
         (defun embark-magit-status (file)
           "Run `magit-status` on repo containing the embark target."
           (interactive "GFile: ")
           (magit-status (locate-dominating-file file ".git")))
         ;; Optionally replace the key help with a completing-read interface
         (setq prefix-help-command #'embark-prefix-help-command)
         (setq embark-action-indicator
               (lambda (map _target)
                 (which-key--show-keymap "Embark" map nil nil 'no-paging)
                 #'which-key--hide-popup-ignore-command)
               embark-become-indicator embark-action-indicator)
         :config
         ;; Hide the mode line of the Embark live/completions buffers
         (add-to-list 'display-buffer-alist
                      '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                        nil
                        (window-parameters (mode-line-format . none)))))
#+end_src

***** Embark-consult
      Configuration merging embark and consult, creating live previews of completion candidates in the Embark collections buffer.
      
      #+begin_src emacs-lisp
        (use-package embark-consult
          :straight t
          :after (embark consult)
          :demand t
          :hook
          (embark-collect-mode . consult-preview-at-point-mode))
      #+end_src

**** Affe
     Affe is another package from the great =minad=, which keeps coming out with these amazing integrations to the emacs default functionality, improving the performance out of the park. In this case, he is trying to come up with a replacement to the commonly known fzf.el and fuzzy-find.el modes, which emulate fuzzy find matching running fzf in an emacs terminal process.

     This ends up not being that performant, as they need the default candidate list to be updated all the time —every time the command is called. Affe tries to improve on that functionality (it is still on development, this is only a test configuration) defining the functions: =affe-grep=, using ripgrep, and =affe-find= using find —it could also be configured to use fd.
     #+begin_src emacs-lisp
       (use-package affe
         :straight (affe :type git :host github :repo "minad/affe" )
         :after orderless
         :bind (("M-s f" . affe-find)
                ("M-s g" . affe-grep))
         :config
         ;; Configure Orderless
         (setq affe-regexp-function #'orderless-pattern-compiler
               affe-highlight-function #'orderless-highlight-matches)
         (consult-customize affe-grep :preview-key (kbd "M-.")))
     #+end_src

** Terminal
   Configuration related to terminal emulators and modes. Recently, 
   I started using vterm which is faster than any of the others.

*** Vterm
    #+begin_src emacs-lisp
      (use-package vterm
        :straight t
        :custom (vterm-max-scrollback 10000)
        )
    #+end_src

**** Vterm toggle
     Package which gives us the possibility to toggle between the terminal and
     the current buffer easily, without distorting the page and allowing for vterm
     buffer creation if the buffer was non-existing.
     #+begin_src emacs-lisp
       (use-package vterm-toggle
         :straight t
         :bind ("C-c x" . vterm-toggle-cd)
         :custom
         (vterm-toggle-reset-window-configration-after-exit 'kill-window-only)
         (vterm-toggle-hide-method 'delete-window))
     #+end_src

** Org-mode
*** Keybindings
    Keybindings for org-mode as well as better defaults. Not in use-package format yet.
    #+BEGIN_SRC emacs-lisp
      (define-key global-map (kbd "C-c o l") 'org-store-link)
      (define-key global-map (kbd "C-c a") 'org-agenda)
      (define-key global-map (kbd "C-c c") 'org-capture)
      (define-key org-mode-map (kbd "C-c o c") 'org-columns)
      (define-key org-mode-map (kbd "C-,") nil)
      (define-key org-mode-map (kbd "C-c o t") 'org-babel-tangle)
    #+END_SRC

*** Initial configuration
    Initial configuration of org-directory and refile.org, with the
    intention of all capture created items to go there before correct refiling.
    #+BEGIN_SRC emacs-lisp
      (setq org-directory "~/OneDriveUPCT/org_files")
      (defvar org-book-list-file (concat org-directory "/book_list.org"))
      (setq
            org-default-notes-file (concat org-directory "/org_agenda/refile.org")
            org-agenda-files (list (concat org-directory "/org_agenda"))
            org-archive-location (concat org-directory "/archive/%s_archive::")
            org-refile-targets (quote ((nil :maxlevel . 5)
                                       (org-agenda-files :maxlevel . 5)
                                       (org-book-list-file :maxlevel . 2)))
            org-src-fontify-natively t
            org-columns-default-format "%50ITEM(Task) %10Effort{:} %10CLOCKSUM"
            org-clock-out-remove-zero-time-clocks t
            org-clock-out-when-done t
            org-agenda-restore-windows-after-quit t
            org-clock-persistence-insinuate t
            org-clock-persist t
            org-clock-in-resume t
            org-startup-with-inline-images t
            )
           (defvar org-archive-file-header-format "#+FILETAGS: ARCHIVE\nArchived entries from file %s\n")
           (add-hook 'org-capture-after-finalize-hook 'org-save-all-org-buffers)
           (add-hook 'org-clock-in-hook 'org-save-all-org-buffers)
           (add-hook 'org-clock-out-hook 'org-save-all-org-buffers)
           (add-hook 'org-mode-hook 'visual-line-mode)
           (org-babel-do-load-languages 'org-babel-load-languages
                                        (append org-babel-load-languages
                                                '((ledger . t))))
    #+END_SRC

**** org-fill-paragraph fix
     Org by default, when calling the fill-paragraph command breaks the org links, creating
     inconsistencies, specially when trying to export to html or other formats.

     I found some ways to fix this, getting input from a bug fix report from [[https://lists.gnu.org/archive/html/emacs-orgmode/2018-04/msg00105.html][Brent Goodrick]].
     #+begin_src emacs-lisp
       (defun bg-org-fill-paragraph-with-link-nobreak-p ()
         "Do not allow `fill-paragraph' to break inside the middle of Org mode links."
         (and (assq :link (org-context)) t))

       (defun bg-org-fill-paragraph-config ()
         "Configure `fill-paragraph' for Org mode."
         ;; Append a function to fill-nobreak-predicate similarly to how org-mode does
         ;; inside `org-setup-filling':
         (when (boundp 'fill-nobreak-predicate)
           (setq-local
            fill-nobreak-predicate
            (org-uniquify
             (append fill-nobreak-predicate
                     '(bg-org-fill-paragraph-with-link-nobreak-p))))))
       (add-hook 'org-mode-hook 'bg-org-fill-paragraph-config)
     #+end_src

*** Beautifying org-mode
    I find that org-mode default lacks some of the prose writing feeling
    when everything is organized, proportioned and just yours. Some of
    the following configuration tries to update the feeling of writing in
    org-mode.

    Starting with org-hide-emphasis-markers. Org-mode by default does not
    hide the markers used when trying to highlight with an specific mode.
    E.g *bold*, /italic/.
    #+begin_src emacs-lisp
      (setq org-hide-emphasis-markers t)
    #+end_src

    I always use "-" to delimit the lists, so change that to use the bullet
    point.
    #+begin_src emacs-lisp
      (font-lock-add-keywords 'org-mode
                              '(("^ *\\([-]\\) "
                                 (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    #+end_src
   
    Set up a proportional font for the headlines, configuring the :font and
    height face arguments.
    #+begin_src emacs-lisp
      (let* (;; (base-font-color     (face-foreground 'default nil 'default))
             (headline           `(:inherit default :weight bold)))

        (custom-theme-set-faces
         'user
         `(org-level-8 ((t (,@headline ))))
         `(org-level-7 ((t (,@headline ))))
         `(org-level-6 ((t (,@headline ))))
         `(org-level-5 ((t (,@headline ))))
         `(org-level-4 ((t (,@headline  :height 1.1))))
         `(org-level-3 ((t (,@headline  :height 1.15))))
         `(org-level-2 ((t (,@headline  :height 1.25))))
         `(org-level-1 ((t (,@headline  :height 1.5))))
         `(org-document-title ((t (,@headline  :height 1.75 :underline nil))))))
    #+end_src

    Change the default face for org-capture-mode-hook on the title, the giant header 1 level height feels awkward on the org-capture template modes.
    #+begin_src emacs-lisp
      (add-hook 'org-capture-mode-hook
                (lambda ()
                  (let* (;; (base-font-color     (face-foreground 'default nil 'default))
                         (headline           `(:inherit default :weight bold)))

                    (face-remap-add-relative 'org-level-1 '(,@headline)))))
    #+end_src

    Hide leading stars on org headlines, instead of using org-bullets. No need
    to have different symbols on the headlines, I'm just not used to it and it
    doesn't feel natural.
    #+begin_src emacs-lisp
      (setq org-hide-leading-stars t)
    #+end_src

*** Refiling
    Refiling setup, using the file name as header. Last line is
    so that we ensure that tasks cannot be tagged as completed
    before subtasks have been done so.
    #+BEGIN_SRC emacs-lisp
      (setq
       org-refile-use-outline-path 'file
       org-outline-path-complete-in-steps nil
       org-refile-allow-creating-parent-nodes 'confirm
       org-enforce-todo-dependencies t
       )
    #+END_SRC

    Adding keywords for easier refiling and capturing. Right side of
    the "|" key is used to indicate the keyword designing completion for
    a certain state.
    #+BEGIN_SRC emacs-lisp
      (setq 
       org-todo-keywords
       (quote ((sequence "TODO(t)" "|" "DONE(d)")
               (sequence "PROJECT(p)" "|" "DONE(d)" "CANCELLED(c)")
               (sequence "WAITING(w)" "|")
               (sequence "|" "CANCELLED(c)")
               (sequence "|" "OPTIONAL(o)")
               (sequence "SOMEDAY(s)" "|" "CANCELLED(c)")
               (sequence "MEETING(m)" "|" "DONE(d)")
               (sequence "NOTE(n)" "|" "DONE(d)")
               )
              )
       org-todo-keyword-faces
       '(
         ("PROJECT" . (:foreground "#a87600" :weight bold))
         ("OPTIONAL" . (:foreground "#08a838" :weight bold))
         ("WAITING" . (:foreground "#fe2f92" :weight bold))
         ("CANCELLED" . (:foreground "#999999" :weight bold))
         ("SOMEDAY" . (:foreground "#ab82ff" :weight bold))
         ("MEETING" . (:foreground "#1874cd" :weight bold))
         ("NOTE" . (:foreground "#fcba03" :weight bold))
         )
       )
    #+END_SRC

*** Org capture
    Capture templates are used with the intention of improving
    the workflow of adding several items and refiling.
    #+BEGIN_SRC emacs-lisp
      (defvar org-blog-directory-file (concat org-directory "/blog/refile.org"))
      (setq
       org-capture-templates
       '(("t" "todo" entry (file org-default-notes-file)
          "* TODO %? :REFILING:\n%a\n" :clock-in t :clock-resume t)
         ("m" "Meeting/Interruption" entry (file org-default-notes-file)
          "* MEETING %? :REFILING:MEETING:\n" :clock-in t :clock-resume t)
         ("i" "Idea" entry (file org-default-notes-file)
          "* %? :REFILING:IDEA:\n" :clock-in t :clock-resume t)
         ("e" "Respond email" entry (file org-default-notes-file)
          "* TODO Write to %? on %? :REFILING:EMAIL: \nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
         ("s" "Someday" entry (file org-default-notes-file)
          "* SOMEDAY %? :REFILING:SOMEDAY:\n" :clock-in t :clock-resume t)
         ("p" "Project creation: @work or @home")
         ("pw" "@work Project entry" entry (file org-default-notes-file)
          "* PROJECT %? :@work:REFILING:PROJECT:\n" :clock-in t :clock-resume t)
         ("ph" "@home Project entry" entry (file org-default-notes-file)
          "* PROJECT %? :@work:REFILING:PROJECT:\n" :clock-in t :clock-resume t)
         ("o" "Optional item" entry (file org-default-notes-file)
          "* OPTIONAL %? :REFILING:OPTIONAL:\n" :clock-in t :clock-resume t)
         ("b" "Book" entry (file org-book-list-file)
          "* %^{TITLE}\n:PROPERTIES:\n:ADDED: %<[%Y-%02m-%02d]>\n:END:%^{AUTHOR}p\n%^{URL}p\n")
         ("n" "Note" entry (file org-default-notes-file)
          "* NOTE %? :REFILING:\n%a\n")
         ("B" "Blog post" entry (file org-blog-directory-file)
          "* TODO #+TITLE: \n#+DATE: \n#+CATEGORY: \n#+TAGS: \n#+SUMMARY: \n #+IMAGE: \n")
         )
       )
    #+END_SRC

*** Org agenda
    Adding hiding the tags on org agenda.
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-hide-tags-regexp (regexp-opt '(
                                                      "REFILING" "MEETING" "IDEA" "EMAIL" "SOMEDAY" "OPTIONAL" "PROJECT" "NOTE" "@work" "@home")))
    #+END_SRC

    Removing inherited and REFILING tags in order to use the tags correctly
    #+BEGIN_SRC emacs-lisp
      (defun qk/org-remove-inherited-tag-strings ()
        "Removes inherited tags from the headline-at-point's tag string.
          Note this does not change the inherited tags for a headline,
          just the tag string."
        (org-set-tags (seq-remove (lambda (tag)
                                    (get-text-property 0 'inherited tag))
                                  (org-get-tags))))

      (defun qk/org-remove-refiling-tag ()
        "Remove the REFILING tag once the item has been refiled."
        (org-toggle-tag "REFILING" 'off))

      (defun qk/org-clean-tags ()
        "Visit last refiled headline and remove inherited tags from tag string."
        (save-window-excursion
          (org-refile-goto-last-stored)
          (qk/org-remove-inherited-tag-strings)
          (qk/org-remove-refiling-tag)))

      (add-hook 'org-after-refile-insert-hook 'qk/org-clean-tags)
    #+END_SRC

    Adding series of tags with the intention of tagging the items for better 
    organization besides the refile file. Adding automated tasks to a tagged item.
    #+BEGIN_SRC emacs-lisp
      (setq org-tag-alist '((:startgroup . nil)
                            ("@work" . ?w)
                            ("@home" . ?h)
                            (:endgroup . nil)
                            ("literature" . ?n)
                            ("coding" . ?c)
                            ("writing" . ?p)
                            ("emacs" . ?e)
                            ("misc" . ?m)))

      (setq
       org-todo-state-tags-triggers
       (quote (
               ;; Move to cancelled adds the cancelled tag
               ("CANCELLED" ("CANCELLED" . t))
               ;; Move to waiting adds the waiting tag
               ("WAITING" ("WAITING" . t))
               ;; Move to a done state removes waiting/cancelled
               (done ("WAITING") ("CANCELLED"))
               ("DONE" ("WAITING") ("CANCELLED"))
               ;; Move to todo, removes waiting/cancelled
               ("TODO" ("WAITING") ("CANCELLED"))
               )
              )
       )
    #+END_SRC

    Configuration of a NEXT actions org-agenda view, getting the first valid TODO item in an open (non-stuck PROJECT). Depending on context, we are able to get the information. The context is represented on projects by tags: @work and @home. I got most of the configuration out of the [[https://www.adventuresinwhy.com/post/next-actions/][adventuresinwhy blog post]], which I recommend for a deeper explanation.
    #+begin_src emacs-lisp
      (defun aw/org-agenda-skip-all-siblings-but-first ()
        "Skip all but the first non-done entry."
        (let (should-skip-entry)
          (unless (org-current-is-todo)
            (setq should-skip-entry t))
          (save-excursion
            ;; If previous sibling exists and is TODO,
            ;; skip this entry
            (while (and (not should-skip-entry) (org-goto-sibling t))
              (when (org-current-is-todo)
                (setq should-skip-entry t))))
          (let ((num-ancestors (org-current-level))
                (ancestor-level 1))
            (while (and (not should-skip-entry) (<= ancestor-level num-ancestors))
              (save-excursion
                ;; When ancestor (parent, grandparent, etc) exists
                (when (ignore-errors (outline-up-heading ancestor-level t))
                  ;; If ancestor is WAITING, skip entry
                  (if (string= "WAITING" (org-get-todo-state))
                      (setq should-skip-entry t)
                    ;; Else if ancestor is TODO, check previous siblings of
                    ;; ancestor ("uncles"); if any of them are TODO, skip
                    (when (org-current-is-todo)
                      (while (and (not should-skip-entry) (org-goto-sibling t))
                        (when (org-current-is-todo)
                          (setq should-skip-entry t)))))))
              (setq ancestor-level (1+ ancestor-level))
              ))
          (when should-skip-entry
            (or (outline-next-heading)
                (goto-char (point-max))))))

      (defun org-current-is-todo ()
        (string= "TODO" (org-get-todo-state)))
    #+end_src
    
    Adding more beautiful org-agenda view with all-icons and better configuration
    of the layout, giving me a lot more information.
    #+BEGIN_SRC emacs-lisp
      (setq org-deadline-warning-days 3)
      (setq org-agenda-block-separator ?—)
      (setq org-agenda-category-icon-alist
            `(("TODO" (list (all-the-icons-faicon "tasks")) nil nil :ascent center)))
      (setq org-agenda-custom-commands
            '(
              ("d" "Agenda" ((agenda "" ((org-agenda-overriding-header "Today's Schedule:")
                                         (org-agenda-span 'day)
                                         (org-agenda-ndays 1)
                                         (org-agenda-start-on-weekday nil)
                                         (org-agenda-start-day "+0d")
                                         (org-agenda-skip-function '(cond ((equal (file-name-nondirectory (buffer-file-name)) "refile.org") (outline-next-heading) (1- (point)))
                                                                          (t (org-agenda-skip-entry-if 'todo 'done))))
                                         (org-agenda-todo-ignore-deadlines nil)))
                             ;; Project tickle list.
                             (todo "PROJECT" ((org-agenda-overriding-header "Project list:")
                                              (org-tags-match-list-sublevels nil)))
                             ;; Refiling category set file wide in file.
                             (tags "REFILING" ((org-agenda-overriding-header "Tasks to Refile:")
                                               (org-tags-match-list-sublevels nil)))
                             ;; Tasks that are unscheduled
                             (todo "TODO" ((org-agenda-overriding-header "Unscheduled Tasks:")
                                           (org-tags-match-list-sublevels nil)
                                           (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))
                                           ))
                             ;; Tasks that are waiting or someday
                             (todo "WAITING|SOMEDAY" ((org-agenda-overriding-header "Waiting/Someday Tasks:")
                                                      (org-tags-match-list-sublevels nil)))
                             (todo "NOTE" ((org-agenda-overriding-header "Notes:")
                                           (org-tags-match-list-sublevels nil)))
                             (agenda "" ((org-agenda-overriding-header "Upcoming:")
                                         (org-agenda-span 7)
                                         (org-agenda-start-day "+1d")
                                         (org-agenda-start-on-weekday nil)
                                         (org-agenda-skip-function '(cond ((equal (file-name-nondirectory (buffer-file-name)) "refile.org")
                                                                           (outline-next-heading) (1- (point)))
                                                                          (t (org-agenda-skip-entry-if 'todo 'done))
                                                                          ))
                                         ;; I should set this next one to true, so that deadlines are ignored...?
                                         (org-agenda-todo-ignore-deadlines nil)))))
              ("N" "Next Actions"
               ((tags-todo "@work"
                           ((org-agenda-overriding-header "Work:")
                            (org-agenda-skip-function #'aw/org-agenda-skip-all-siblings-but-first)))
                (tags-todo "@home"
                           ((org-agenda-overriding-header "Home:")
                            (org-agenda-skip-function #'aw/org-agenda-skip-all-siblings-but-first)))
                )))

            ;; If an item has a (near) deadline, and is scheduled, only show the deadline.
            org-agenda-skip-scheduled-if-deadline-is-shown t)
    #+END_SRC

    

**** org-agenda hydra
     Using the hydra in the hydra wiki page ([[https://github.com/abo-abo/hydra/wiki/Org-agenda][here]]), we get a ton of information that can be used in the org-agenda window. We also inhibit which-key to avoid overcrowding the minibuffer.
     #+begin_src emacs-lisp
       (defhydra hydra-org-agenda (:pre (setq which-key-inhibit t)
                                        :post (setq which-key-inhibit nil)
                                        :hint none)
         "
       Org agenda (_q_uit)

       ^Clock^      ^Visit entry^              ^Date^             ^Other^
       ^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
       _ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
       _co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
       _cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
       _cj_ jump    _o_   link                 _+_  do later      ^^
       ^^           ^^                         _-_  do earlier    ^^
       ^^           ^^                         ^^                 ^^
       ^View^          ^Filter^                 ^Headline^         ^Toggle mode^
       ^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
       _vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
       _vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
       _vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
       _vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
       _vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
       _vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
       _vp_ prev span  ^^                       ^^                 ^^
       _vr_ reset      ^^                       ^^                 ^^
       ^^              ^^                       ^^                 ^^
       "
         ;; Entry
         ("hA" org-agenda-archive-default)
         ("hk" org-agenda-kill)
         ("hp" org-agenda-priority)
         ("hr" org-agenda-refile)
         ("h:" org-agenda-set-tags)
         ("ht" org-agenda-todo)
         ;; Visit entry
         ("o"   link-hint-open-link :exit t)
         ("<tab>" org-agenda-goto :exit t)
         ("TAB" org-agenda-goto :exit t)
         ("SPC" org-agenda-show-and-scroll-up)
         ("RET" org-agenda-switch-to :exit t)
         ;; Date
         ("dt" org-agenda-date-prompt)
         ("dd" org-agenda-deadline)
         ("+" org-agenda-do-date-later)
         ("-" org-agenda-do-date-earlier)
         ("ds" org-agenda-schedule)
         ;; View
         ("vd" org-agenda-day-view)
         ("vw" org-agenda-week-view)
         ("vt" org-agenda-fortnight-view)
         ("vm" org-agenda-month-view)
         ("vy" org-agenda-year-view)
         ("vn" org-agenda-later)
         ("vp" org-agenda-earlier)
         ("vr" org-agenda-reset-view)
         ;; Toggle mode
         ("ta" org-agenda-archives-mode)
         ("tA" (org-agenda-archives-mode 'files))
         ("tr" org-agenda-clockreport-mode)
         ("tf" org-agenda-follow-mode)
         ("tl" org-agenda-log-mode)
         ("td" org-agenda-toggle-diary)
         ;; Filter
         ("fc" org-agenda-filter-by-category)
         ("fx" org-agenda-filter-by-regexp)
         ("ft" org-agenda-filter-by-tag)
         ("fr" org-agenda-filter-by-tag-refine)
         ("fh" org-agenda-filter-by-top-headline)
         ("fd" org-agenda-filter-remove-all)
         ;; Clock
         ("cq" org-agenda-clock-cancel)
         ("cj" org-agenda-clock-goto :exit t)
         ("ci" org-agenda-clock-in :exit t)
         ("co" org-agenda-clock-out)
         ;; Other
         ("q" nil :exit t)
         ("gd" org-agenda-goto-date)
         ("." org-agenda-goto-today)
         ("gr" org-agenda-redo))
     #+end_src


**** org-agenda keybindings
     Adding custom agenda commands, with the intention of making the refiling and
     tagging workflow a bit faster, as C-c C-w might be cumbersome to write in agenda-view.
     #+BEGIN_SRC emacs-lisp
       (add-hook 'org-agenda-mode-hook
                 (lambda ()
                   (local-set-key (kbd "r") 'org-agenda-refile)
                   (local-set-key (kbd "?") 'hydra-org-agenda/body)))
     #+END_SRC

*** Org source blocks
    Tabs on org-mode source blocks try to find the language added.
    If for some reason the language on the source tag doesn't exist
    add 4 spaces.
    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-tab-first-hook
                (lambda ()
                  (when (org-in-src-block-p t)
                    (let* ((elt (org-element-at-point))
                           (lang (intern (org-element-property :language elt)))
                           (langs org-babel-load-languages))
                      (unless (alist-get lang langs)
                        (indent-to 4))))))
    #+END_SRC

*** Archiving of files
    Creating function which archives all files which contain only done (not necessarily
    in a DONE state.) items, with the intention of making org-agenda quicker to proccess.

    #+BEGIN_SRC emacs-lisp
      (defun qk/archive-done-org-files ()
        "Cycles all org files through checking function."
        (interactive) 
        (save-excursion
          (mapc 'check-org-file-finito (directory-files (concat org-directory "/org-agenda") t ".org$"))
          ))

      (defun check-org-file-finito (f)
        "Checks TODO keyword items are DONE then archives."
        (find-file f)
        ;; Shows open Todo items whether agenda or todo
        (let (
              (kwd-re
               (cond (org-not-done-regexp)
                     (
                      (let ((kwd
                             (completing-read "Keyword (or KWD1|KWD2|...): "
                                              (mapcar #'list org-todo-keywords-1))))
                        (concat "\\("
                                (mapconcat 'identity (org-split-string kwd "|") "\\|")
                                "\\)\\>")))
                     ((<= (prefix-numeric-value) (length org-todo-keywords-1))
                      (regexp-quote (nth (1- (prefix-numeric-value))
                                         org-todo-keywords-1)))
                     (t (user-error "Invalid prefix argument: %s")))))
          (if (= (org-occur (concat "^" org-outline-regexp " *" kwd-re )) 0)
              (rename-file-buffer-to-org-archive)
            (kill-buffer (current-buffer))
            )))

      (defun rename-file-buffer-to-org-archive ()
        "Renames current buffer and file it's visiting."
        (let ((name (buffer-name))
              (filename (buffer-file-name))
              )
          (if (not (and filename (file-exists-p filename)))
              (error "Buffer '%s' is not visiting a file!" name)
            (let ((new-name (concat (file-name-sans-extension filename) ".org_archive")))
              (if (get-buffer new-name)
                  (error "A buffer named '%s' already exists!" new-name)
                (rename-file filename new-name 1)
                (rename-buffer new-name)
                (set-visited-file-name new-name)
                (set-buffer-modified-p nil)
                (kill-buffer (current-buffer))
                (message "File '%s' successfully archived as '%s'."
                         name (file-name-nondirectory new-name)))))))
    #+END_SRC

*** Extension packages
**** toc-org
     Package designed to update a table of contents for the org-mode file, super
     useful when creating readme files, which are easier to format in org.
     #+begin_src emacs-lisp
       (use-package toc-org
         :straight t
         :hook (org-mode . toc-org-mode))
     #+end_src

**** Org-roam
     I use the Zettelkasten (slip-box) method for taking and recalling notes and
     information. To be able to do so, I started with my own workflow, adding
     org-mode links to the different notes, and has been working for me for 
     close to a month. As a way of improving this workflow, I decided to give
     org-roam a chance.

     #+BEGIN_SRC emacs-lisp 
       (use-package org-roam
         :straight t
         :hook
         (after-init . org-roam-mode)
         :custom
         (org-roam-directory "~/Documents/slip-box/")
         (org-roam-capture-templates '(
                                       ("d" "default" plain (function org-roam--capture-get-point)
                                        "%?"
                                        :file-name "%<%Y%m%d%H%M%S>-${slug}"
                                        :head "#+title: ${title}\n#+roam_key: \n#+roam_tags: \n"
                                        :unnarrowed t)))
         :bind (:map org-roam-mode-map
                     (("C-c n l" . org-roam)
                      ("C-c n f" . org-roam-find-file)
                      ("C-c n g" . org-roam-graph))
                     :map org-mode-map
                     (("C-c n i" . org-roam-insert)
                      ("C-c n I" . org-roam-insert-immediate))
                     :map org-roam-backlinks-mode-map
                     ("w" . visual-line-mode)))
     #+END_SRC

***** Hooks
      Adding the execution of certain functions when the org-roam-file-setup-hook
      is run, for example, adding spelling correction functionality.
      #+begin_src emacs-lisp
        (add-hook 'org-roam-file-setup-hook (lambda ()
                                              (flyspell-mode t)))
      #+end_src

***** Org-roam protocol
      After having configured the org-protocol, the org-roam-protocol will open the links
      that have been created with the org-roam-graph function in order to allow for faster
      browsing when outilining blog posts or articles.
      #+begin_src emacs-lisp :tangle no
        (use-package org-roam-protocol
          :straight nil)
      #+end_src

**** Org-pdftools
     Org-pdftools is the mantained version of the package org-pdfview, which allos for annotations
     and org-links to different pages of the pdf, instead of giving the normal 500 kilometers wide
     slug that org-mode gives.
     #+begin_src emacs-lisp
       (use-package org-pdftools
         :straight t
         :hook (org-mode . org-pdftools-setup-link))
     #+end_src

**** Exporting to epub
     This is an attempt to have org-mode export to epub, in order to produce ebooks
     that I can later convert to mobi in order to include in my kindle. The books
     that was interested in converting would most likely be collections of blog posts.
     #+begin_src emacs-lisp
       (use-package ox-epub
         :straight t)
     #+end_src

**** Org-pomodoro
     Adding pomodoro support to emacs, with the intention of adding the effort
     column in pomodoros. Taking a lot of info from [[https://git.alenshaw.com/shuxiao9058/dotemacs.d/raw/master/dotemacs.d/lisp/init-pomodoro.el][shuxiao9058]] config.

     I'm also adding a function to be able to set the effort in pomodoros, to avoid
     possible missunderstandings.
     #+begin_src emacs-lisp
       (defun ndk/org-set-effort-in-pomodoros (&optional n)
         (interactive "P")
         (setq n (or n (string-to-number (read-from-minibuffer "How many pomodoros: " nil nil nil nil "1" nil))))
         (let* ((mins-per-pomodoro-prop (org-entry-get (point) "MINUTES_PER_POMODORO" t))
                (mins-per-pomodoro (if mins-per-pomodoro-prop
                                       (string-to-number mins-per-pomodoro-prop)
                                     25)))
           (org-set-effort nil (org-duration-from-minutes (* n mins-per-pomodoro)))))
       (use-package org-pomodoro
         :straight t
         :demand t
         :hook (org-pomodoro-break-finished .
                                            (lambda ()
                                              (interactive)
                                              (point-to-register 1)
                                              (org-clock-goto)
                                              (org-pomodoro)
                                              (register-to-point 1)
                                              ))
         :custom
         (org-pomodoro-keep-killed-pomodoro-time t)
         (org-pomodoro-start-sound (concat user-emacs-directory "extra/loud-bell.wav"))
         (org-pomodoro-short-break-sound (concat user-emacs-directory "extra/bell.wav"))
         :bind-keymap("C-c o p" . qk/org-pomodoro-mode-global-map)
         :bind (:map org-agenda-mode-map ("P" . org-pomodoro))
         :init 
         (defvar shu/org-pomodoro-columns-format
           "%22SCHEDULED %CATEGORY %42ITEM %4Effort(Effort){:} %4CLOCKSUM_T(Time)")
         (defun shu/org-pomodoro-columns ()
           (interactive)
           (org-columns shu/org-pomodoro-columns-format))

         (defun shu/org-pomodoro-agenda-columns ()
           (interactive)
           (let ((org-agenda-overriding-columns-format shu/org-pomodoro-columns-format))
             (org-agenda-columns)))
         (defvar qk/org-pomodoro-mode-global-map
           (let ((map (make-sparse-keymap)))
             (define-key map "I" 'org-pomodoro)
             (define-key map "a" 'shu/org-pomodoro-agenda-columns)
             (define-key map "c" 'shu/org-pomodoro-columns)
             (define-key map "e" 'ndk/org-set-effort-in-pomodoros) map)
           "Key map to scope `org-pomodoro' bindings for global usage.
                       The idea is to bind this to a prefix sequence, so that its
                       defined keys follow the pattern of <PREFIX> <KEY>."))
     #+end_src

 * Org-babel
#+begin_src emacs-lisp
  (use-package ob
    :custom (org-confirm-babel-evaluate nil))
#+end_src
    
** Version control
*** Symlinks
    As part of this =dot_files= repo, my configuration philosofy uses
    symlinks to control the files within the repo but still benefit from
    the modifying on only individual files, instead of copying and pasting.
    The =vc= emacs package always asks whether I intend to follow the links
    that are git-controlled, obviously yes.

    #+begin_src emacs-lisp
      (setq vc-follow-symlinks t)
    #+end_src

*** Magit forge
    Magit with the integration of Github Issues.
    #+BEGIN_SRC emacs-lisp
      (use-package forge
        :straight t
        :after magit
        :config (progn 
                  (transient-append-suffix 'forge-dispatch '(0)
                    ["Edit"
                     ("e a" "assignees" forge-edit-topic-assignees)
                     ("e r" "review requests" forge-edit-topic-review-requests)])
                  ))

      ;; Setting up forge token.
      (setq auth-sources '("~/.authinfo"))
    #+END_SRC

*** Magit
    Obviously [[https://magit.vc/][Magit]].
    #+begin_src emacs-lisp
      (use-package magit
        :straight t
        :bind ("C-x g" . magit-status)
        :hook (after-save . magit-after-save-refresh-status)
        :hook (git-commit-mode . (lambda ()
                                   (set-fill-column 72)))
        :custom 
        (git-commit-summary-max-length 50)
        (magit-diff-hide-trailing-cr-characters t))
    #+end_src

** Project management
   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :straight t
       ;; Working on ubuntu, if you are not, change fdfind to fd.
       :custom (projectile-generic-command "fdfind . -0 --type f --color=never")
       :config(progn 
                ;; (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
                (setq projectile-project-search-path '("~/Documents/"))
                (projectile-global-mode)))
     (with-eval-after-load 'projectile
       (add-to-list 'projectile-project-root-files-bottom-up "pubspec.yaml")
       (add-to-list 'projectile-project-root-files-bottom-up "BUILD"))
   #+END_SRC

** Snippets
*** Yasnippet
    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :straight t
        :config (yas-global-mode))
    #+END_SRC

*** Better yasnippets for modes.
    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet-snippets
        :straight t)
    #+END_SRC

** Programming
*** Completion Overlay
**** Company
    Company is used for better completion on the fly. :warning: UPDATE 2021/05/20: Instead of using company, the master branch will now be testing [[https://github.com/minad/corfu][corfu]], which seems a package that is better align with my goal of making the configuration as modular as possible.

    For completion reasons, I still leave the company configuration here, just in case someone might want to give it a try.
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package company
        :straight t
        :config (progn 
                  (global-company-mode 1)
                  (setq company-show-numbers t)
                  (setq company-dabbrev-downcase 0)
                  (setq company-idle-delay 0)))
    #+END_SRC

    Adding completion on tab.
    #+BEGIN_SRC emacs-lisp :tangle no
      (defun tab-indent-or-complete ()
        (interactive)
        (if (minibufferp)
            (minibuffer-complete)
          (if (or (not yas-minor-mode)
                  (null (do-yas-expand)))
              (if (check-expansion)
                  (company-complete-common)
                (indent-for-tab-command)))))
      (global-set-key [backtab] 'tab-indent-or-complete)
    #+END_SRC

    Adding prescient sorting and filtering mechanism with the intention
    of enabling a better candidate mechanism.
    #+begin_src emacs-lisp :tangle no
      (use-package company-prescient
        :straight t
        :config (company-prescient-mode 1))
    #+end_src

**** Corfu
     As I mentioned in the company configuration update. I can't seem to come around using company for its heavy weight obsession. Instead of trying to create a completion API, let Emacs do its work (using =completion-at-point-functions=, which are normally defined by programming modes), improving the performance in the process.

     Corfu also uses a child-frame, which is one of the star features of Emacs 26. One of the possible user downsides of using Corfu is that at the moment it doesn't support idle-completion, which could be interesting for programming. I personally find that is just a matter of getting used to the new workflow of completing if you need it.

     Another option is to also set up the `TAB' for cycling through the candidates, but I don't find it particularly interesting. I prefer the company convention of using C-n and C-p.
     #+begin_src emacs-lisp
       (defvar gruvbox-dark1 "#3c3836")
       (defvar gruvbox-bright_purple "#d3869b")
       (defvar gruvbox-dark2 "#504945")

       (use-package corfu
         :straight t
         :bind (:map corfu-map
                     ("C-n" . corfu-next)
                     ("C-p" . corfu-previous))
         :custom (corfu-cycle t) (corfu-global-mode t)
         :custom-face 
         (corfu-background ((t (:background ,gruvbox-dark1))))
         (corfu-current ((t (:foreground ,gruvbox-bright_purple :background ,gruvbox-dark2))))
         (corfu-bar ((t (:background ,gruvbox-dark2))))
         (corfu-border ((t (:background ,gruvbox-dark1))))
         :config (corfu-global-mode))

       (use-package emacs
         :init
         ;; TAB cycle if there are only few candidates
         (setq completion-cycle-threshold 3)

         ;; Enable indentation+completion using the TAB key.
         ;; `completion-at-point' is often bound to M-TAB.
         (setq tab-always-indent 'complete))

     #+end_src
     
*** Server side functionality (LSP)
    Lsp-mode for server completion.
**** Flycheck
     Sintax checking on the fly.
     #+begin_src emacs-lisp
       (use-package flycheck
         :straight t)

       (flycheck-define-checker proselint
         "A linter for prose."
         :command ("proselint" source-inplace)
         :error-patterns
         ((warning line-start (file-name) ":" line ":" column ": "
                   (id (one-or-more (not (any " "))))
                   (message) line-end))
         :modes (text-mode markdown-mode gfm-mode org-mode))
       (add-to-list 'flycheck-checkers 'proselint)

       (flycheck-define-checker vale
         "A checker for prose"
         :command ("vale" "--output" "line"
                   source)
         :standard-input nil
         :error-patterns
         ((error line-start (file-name) ":" line ":" column ":" (id (one-or-more (not (any ":")))) ":" (message) line-end))
         :modes (markdown-mode org-mode text-mode))
       (add-to-list 'flycheck-checkers 'vale 'append)
     #+end_src

***** Flycheck-vale
      flycheck-vale is a package trying to provide seemless integration
      with the =vale= prose linter, which is written in go, it is fast and
      maintained, couldn't be a better option.
      #+begin_src emacs-lisp :tangle no
        (use-package flycheck-vale
          :straight t
          :config (flycheck-vale-setup))
      #+end_src

**** Treemacs
     Treemacs is a package explorer that has been created taking a ton of inspiration
     from Eclipse's package explorer. It allows to have a ton of project and workspace
     functionality that I find interesting for some of my applications. Mostly it will
     be used when there are a ton of files in the project and I can benefit from having
     a bird-view.

     I use the following keybindings:
    
     - =C-c T=: =treemacs=, I normally use it to close treemacs.
     - =C-c t=: =treemacs-select-window=, this second one is the one that I most use,
       considering that treemacs opens when this command is called and the treemacs
       window was hidden.
     #+begin_src emacs-lisp
       (use-package treemacs
         :straight t
         :bind (:map global-map (("C-c T" . treemacs)
                                 ("C-c t" . treemacs-select-window))))
     #+end_src

***** treemacs-projectile
      treemacs-projectile is a little extension to the comprehensive treemacs functionality,
      focused on providing an easy exprerience adding projects, specially some of which have
      already been imported by projectile.
      #+begin_src emacs-lisp
        (use-package treemacs-projectile
          :straight t)
      #+end_src
     
**** lsp-mode
     #+BEGIN_SRC emacs-lisp
       (use-package lsp-mode
         :straight t
         :commands (lsp lsp-deferred)
         :hook
         (python-mode . lsp-deferred)
         (latex-mode . lsp-deferred) ;; :warning: testing
         (lsp-mode . lsp-enable-which-key-integration)
         (lsp-mode . (lambda () (setq-local company-minimum-prefix-length 1)))
         :init
         (setq gc-cons-threshold 100000000)
         (setq read-process-output-max (* 1024 1024))
         (setq lsp-completion-provider :none)
         (setq lsp-idle-delay 0.500)
         (setq lsp-enable-file-watchers nil)
         (setq lsp-signature-auto-activate nil)
         (setq lsp-headerline-breadcrumb-enable nil)
         (setq lsp-enable-links nil)
         :config (define-key lsp-mode-map (kbd "C-c l") lsp-command-map))

     #+END_SRC

***** Html preview.
      Adding the html preview filter, which uses the httpd server and impatient-mode,
      in order to process all the information. Keep in mind that you would need to use
      the impatient-mode command on all the buffers that need to be refreshed on change,
      including possible stylesheets that are connected to the initial 
      #+begin_src emacs-lisp
        (use-package mhtml-mode
          :straight nil
          :init
          (defun qk/html-preview ()
            "Preview html using httpd and impatient-mode"
            (interactive)
            (unless (process-status "httpd")
              (httpd-start))
            (impatient-mode)
            (imp-visit-buffer))) 
      #+end_src


      
***** lsp-ui
      Better ui for lsp-mode, adding el-doc.
      #+BEGIN_SRC emacs-lisp
        (use-package lsp-ui
          :requires (flycheck)
          :straight t
          :commands lsp-ui-mode
          :custom (lsp-ui-sideline-show-code-actions nil))
      #+END_SRC

***** Python programming
      Making sure the executable for python is not longer "python", but default to
      using the "python3" binary. Remember that pip3, when installing
      python-language-server saves the information in ~/.local/bin, which may not be
      in your path, check the "echo $PATH" output.
      #+begin_src emacs-lisp
        (use-package python
          :custom (python-shell-interpreter "python3"))
      #+end_src

      Adding pip-requirements in order to benefit from syntax
      and completion for pip requirements files.
      #+begin_src emacs-lisp
        (use-package pip-requirements
          :demand t
          :straight t)  
      #+end_src

***** treemacs-all-the-icons
      Adding all-the-icons support to treemacs, configuring better default icons.
      #+begin_src emacs-lisp
        (use-package treemacs-all-the-icons
          :straight t
          :config
          (treemacs-load-theme "Netbeans"))
      #+end_src

***** Dap-mode
      Server side debugging protocol, seemed to be installed with lsp-dart, I'm adding the package here just to make sure, as I couldn't load lsp-dart or lsp-java because dap-mode wasn't available.
      #+begin_src emacs-lisp
        (use-package dap-mode
          :straight t
          :after lsp-mode
          :bind (:map lsp-mode-map
                      ("C-c l d" . dap-hydra))
          :hook (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra)))
          :config (dap-auto-configure-mode))
        (use-package dap-python
          :after dap-mode
          :straight nil)
      #+end_src

** Extra
*** Eww
    Eww is the emacs browser, which can have different integrations and
    workflows, specially if you are reading text, as it has a great
    html parser which could be customizable. For eww settings I'm using
    the configuration that Prot shows on his [[https://protesilaos.com/dotemacs/#h:4523c31a-d638-4ab2-bc2c-4bdeadc2c86b][website]].

**** HTML parser
     Configuring the html parser in order to avoid colors, which may not
     be working correctly, anyway.
     #+begin_src emacs-lisp
       (use-package shr
         :custom
         (shr-use-fonts nil)
         (shr-use-colors nil)
         (shr-max-image-proportion 0.7)
         (shr-image-animate nil)
         (shr-width (current-fill-column)))
     #+end_src

**** Custom functions regarding keymaps and browse history
     #+begin_src emacs-lisp
       (defun prot/eww-visit-history (&optional arg)
         "Revisit a URL from `eww-prompt-history' using completion.
           With \\[universal-argument] produce a new buffer."
         (interactive "P")
         (let ((history eww-prompt-history)  ; eww-bookmarks
               (new (if arg t nil)))
           (eww
            (completing-read "Visit website from history: " history nil t)
            new)))
       (defun prot/eww-find-feed ()
         "Produce Occur buffer with RSS/Atom links from XML source."
         (interactive)
         (eww-view-source)
         (occur "\\(rss\\|atom\\)\\+xml.*href=[\"']\\(.*?\\)[\"']" "\\2")
         (View-quit))

       (defvar qk/eww-mode-global-map
         (let ((map (make-sparse-keymap)))
           (define-key map "s" 'eww-search-words)
           (define-key map "o" 'eww-open-in-new-buffer)
           (define-key map "f" 'eww-open-file)
           (define-key map "w" 'prot/eww-visit-history)
           (define-key map "c" 'browse-url-chrome)
           (define-key map "F" 'prot/eww-find-feed)
           map)
         "Key map to scope `eww' bindings for global usage.
         The idea is to bind this to a prefix sequence, so that its
         defined keys follow the pattern of <PREFIX> <KEY>.")
     #+end_src

**** Eww configuration
     Adding all the configuration regarding the eww variables and
     a possible keymap inside of eww.

     #+begin_src emacs-lisp
       (use-package eww
         :custom
         (eww-restore-desktop t)
         (eww-desktop-remove-duplicates t)
         (eww-header-line-format "%u")
         (eww-search-prefix "https://duckduckgo.com/html/?q=")
         (eww-download-directory "~/Downloads/")
         (eww-suggest-uris
          '(eww-links-at-point
            thing-at-point-url-at-point))
         (eww-bookmarks-directory "~/.emacs.d/eww-bookmarks/")
         (eww-history-limit 150)
         (eww-use-external-browser-for-content-type
          "\\`\\(video/\\|audio/\\|application/pdf\\)")
         (eww-browse-url-new-window-is-tab nil)
         (eww-form-checkbox-selected-symbol "[X]")
         (eww-form-checkbox-symbol "[ ]")

         :bind-keymap ("C-c w" . qk/eww-mode-global-map)
         :bind (:map eww-mode-map
                     ("n" . next-line)
                     ("p" . previous-line)
                     ("f" . forward-char)
                     ("b" . backward-char)
                     ("a" . org-eww-copy-for-org-mode)
                     ("B" . eww-back-url)
                     ("N" . eww-next-url)
                     ("P" . eww-previous-url)))
     #+end_src

     Also adding eww as the default browser for the browse-url
     package inside emacs.
     #+begin_src emacs-lisp :tangle no
       (use-package browse-url
         :after eww
         :custom
         (browse-url-browser-function 'eww-browse-url))
     #+end_src

     Configuring mailcap mime data in order to be able to view pdfs
     from eww buffers, using the pdf-view-mode of pdf-tools.

     :warning: Update 26/01/21: Untangling this config, testing if the eww configuration
     is enough to open the pdfs in the browser, avoiding problems.
     #+begin_src emacs-lisp
       (use-package mailcap
         :config (add-to-list 'mailcap-user-mime-data
                              '((type . "application/pdf")
                                (viewer . pdf-view-mode))))  
     #+end_src

*** Emojify
    Adding emoji support in order to be able to use it in
    org-mode files, with using them in a blog post in sight.
    #+begin_src emacs-lisp
      (use-package emojify
        :straight t
        :hook (after-init . global-emojify-mode))  
    #+end_src

*** Todo in code
    Using the hl-todo package, we are able to highlight keywords related to
    the working environment, like: TODO, FIXME and some more.
    #+begin_src emacs-lisp
      (use-package hl-todo
        :hook (prog-mode . hl-todo-mode)
        :straight t
        :config
        (setq hl-todo-highlight-punctuation ":"
              hl-todo-keyword-faces
              `(("TODO"       warning bold)
                ("FIXME"      error bold)
                ("HACK"       font-lock-constant-face bold)
                ("REVIEW"     font-lock-keyword-face bold)
                ("NOTE"       success bold)
                ("DEPRECATED" font-lock-doc-face bold))))
    #+end_src
* conda python
  #+begin_src emacs-lisp
    (use-package conda
      :straight t
      :custom (conda-anaconda-home "/home/mkessler/anaconda3/")
      (conda-env-home-directory "/home/mkessler/anaconda3/")
      :config
      (conda-env-initialize-interactive-shells)
      ;; if you want eshell support, include:
      (conda-env-initialize-eshell)
      ;; if you want auto-activation (see below for details), include:
      ;;(conda-env-autoactivate-mode t)
      ;;:hook (conda-postactivate . lsp-workspace-restart)
      )
    (use-package python
      :init
      (defun my-compile ()
        "Use compile to run python programs"
        (interactive)
        (compile (concat "python3 " (buffer-name))))
      (setq compilation-scroll-output t)
      :bind ("C-c C-u" . my-compile)
      :custom (compilation-ask-about-save nil))
#+end_src


* ipython ein
  #+begin_src emacs-lisp :tangle no
    (use-package ein
      :straight t)
#+end_src

* Jupyter configuration
  #+begin_src emacs-lisp
    (use-package jupyter
      :straight t)

    (use-package ob
      :custom (org-babel-default-header-args:jupyter-python '((:async . "yes")
                                                                     (:session . "py")))
      (jupyter-repl-echo-eval-p t)
      :config (progn
                (org-babel-do-load-languages 'org-babel-load-languages
                                 (append org-babel-load-languages
                                         '((jupyter . t))))))

#+end_src


