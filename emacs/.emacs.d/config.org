+STARTUP: showeverything
#+PROPERTY: header-args :results none

** Lexical binding
   #+begin_src emacs-lisp
     ;;; config.el --- apply lexical binding to all config  -*- lexical-binding: t -*-
   #+end_src
   
** Keybindings
** Evil
*** Evil-mode
    [[https://github.com/emacs-evil/evil][Evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim, and provides facilities for writing custom extensions. Also see our page on EmacsWiki.
    #+begin_src emacs-lisp
      (defun qk/set-quit-with-scape ()
        (define-key evil-normal-state-map [escape] 'keyboard-quit)
        (define-key evil-visual-state-map [escape] 'keyboard-quit)
        (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
        (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
        (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
        (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
        (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit))

      (defun qk/stop-using-emacs-bindings ()
        "Function created to flash the screen if I'm using old Emacs bindings, and
      not the evil ones I'm trying to learn."
        (interactive)
        (message "Stop using Emacs bindings: use evil-mode ones please."))

      (use-package evil
        :straight t
        :demand t
        :bind
        ("C-x 0" . qk/stop-using-emacs-bindings)
        ("C-x 1" . qk/stop-using-emacs-bindings)
        ("C-x 2" . qk/stop-using-emacs-bindings)
        ("C-x 3" . qk/stop-using-emacs-bindings)
        ("C-x b" . qk/stop-using-emacs-bindings)
        ("C-x k" . qk/stop-using-emacs-bindings)
        ("C-x e" . qk/stop-using-emacs-bindings)
        ("M-x" . qk/stop-using-emacs-bindings)
        :custom
        (evil-want-integration t)
        (evil-want-keybinding nil)
        (evil-want-C-u-scroll t)
        (evil-want-C-i-jump nil)
        (evil-respect-visual-line-mode t)
        (evil-undo-system 'undo-tree)
        :config
        (qk/set-quit-with-scape)
        ;; Use visual line motions even outside of visual-line-mode buffers
        (evil-global-set-key 'motion "j" 'evil-next-visual-line)
        (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

        (evil-set-initial-state 'messages-buffer-mode 'normal)
        (evil-set-initial-state 'magit-status-mode 'normal)
        (evil-set-initial-state 'git-commit-mode 'insert)
        (evil-set-initial-state 'dashboard-mode 'normal)
        (evil-set-initial-state 'org-agenda-mode 'motion)
        (evil-normalize-keymaps)
        (evil-mode 1))
    #+end_src

*** Evil-collection
    #+begin_src emacs-lisp
      (use-package evil-collection
        :straight t
        :demand t
        :custom
        (evil-collection-outline-bind-tab-p nil)
        (evil-collection-setup-minibuffer t)
        :config
        (evil-collection-init))
    #+end_src

*** Evil-org
    Supplemental evil-mode key-bindings to Emacs org-mode. This project is a continuation of https://github.com/edwtjo/evil-org-mode/blob/master/evil-org.el by Edward Tjörnhammar.
    #+begin_src emacs-lisp
      (use-package evil-org
        :straight t
        :after org
        :custom 
        (evil-org-special-o/O '(table-row item))
        :hook
        (org-mode . evil-org-mode)
        :config
        (require 'evil-org-agenda)
        (evil-org-agenda-set-keys)
        (evil-org-set-key-theme '(textobjects insert navigation additional shift))

        (evil-define-key 'motion org-agenda-mode-map
          "ss" 'org-agenda-schedule))
    #+end_src

** which-key
    =which-key= is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup. For example, after enabling the minor mode if you enter C-x and wait for the default of 1 second the minibuffer will expand with all of the available key bindings that follow C-x (or as many as space allows given your settings).
    #+begin_src emacs-lisp
      (use-package which-key
        :straight t
        :defer 1
        :config
        (which-key-setup-minibuffer)
        (which-key-mode))
#+end_src

** Personal bindings
   Here are the personal bindings that I control, having defined them using the =general-global-menu= macro, which makes the defining and configuration of key-pockets really easy and painless.
   #+begin_src emacs-lisp
     (require 'keybindings)
    #+end_src

** Themes
** Initial theme list
   I add the theme list here to be able to add to it when a theme is tangled, considering that I will most likely want to toggle two themes, the ones that are tangled: dark and light.
   #+begin_src emacs-lisp
     (setq qk/themes-list nil)
     (setq qk/themes-index 1)
   #+end_src
    
** Nord theme
   #+begin_src emacs-lisp
     (use-package doom-themes
       :straight t
       :init
       (add-to-list 'qk/themes-list 'doom-nord))
   #+end_src

** Solarized theme
   This is the second theme in my book. I really like the solarized theme, but Gruvbox stills wins it. The reason I have it here is because of its light theme.
   #+begin_src emacs-lisp
     (use-package solarized-theme
       :straight t
       :custom
       ;; make the fringe stand out from the background
       (solarized-distinct-fringe-background t)

       ;; Don't change the font for some headings and titles
       (solarized-use-variable-pitch nil)

       ;; Use less bolding
       (solarized-use-less-bold t)

       ;; Use more italics
       (solarized-use-more-italic t)

       ;; Use less colors for indicators such as git:gutter, flycheck and similar
       (solarized-emphasize-indicators nil)

       ;; Don't change size of org-mode headlines (but keep other size-changes)
       (solarized-scale-org-headlines nil)

       ;; Avoid all font-size changes
       (solarized-height-minus-1 1.0)
       (solarized-height-plus-1 1.0)
       (solarized-height-plus-2 1.0)
       (solarized-height-plus-3 1.0)
       (solarized-height-plus-4 1.0)
       :init
       (add-to-list 'qk/themes-list 'solarized-light-high-contrast))
   #+end_src

** Toggle theme
   I found this function to cycle through a list of themes, which is defined before the function. In my opinion toggling from light to dark is key when working in the evenings.
   #+begin_src emacs-lisp
     (straight-use-package 'consult)
     (defun qk/cycle-theme ()
       "Change the theme to the next index in the `qk/themes-list'. I would normally use this for switching from light to dark modes."
       (interactive)
       (setq qk/themes-index (% (1+ qk/themes-index) (length qk/themes-list)))
       (qk/load-indexed-theme))

     (defun qk/load-indexed-theme ()
       (consult-theme (nth qk/themes-index qk/themes-list)))

     (defun qk/try-load-theme (theme)
       (if (ignore-errors (load-theme theme :no-confirm))
           (mapcar #'disable-theme (remove theme custom-enabled-themes))
         (message "Unable to find theme file for ‘%s’" theme)))
     (qk/load-indexed-theme)

     (+general-global-toggle
      "T" 'qk/cycle-theme)
   #+end_src

** After-load-theme-hook
   Emacs does not have an =after-load-theme-hook=, which a I find key for adding or changing some of the faces dinamically. Not everything is lost, we still have the =advice= sintax. We can advise the change-theme function to define a hook.
   #+begin_src emacs-lisp
     (defvar after-load-theme-hook nil
       "Hook run after a color theme is loaded using `load-theme'.")
     (defadvice consult-theme (after run-after-load-theme-hook activate)
       "Run `after-load-theme-hook'."
       (run-hooks 'after-load-theme-hook))
   #+end_src

** Better defaults
*** Smooth-scrolling
    Smooth-scrolling inspired in the sublime editor.
    #+begin_src emacs-lisp
      (use-package sublimity-scroll
        :straight sublimity
        :custom (scroll-margin 10)
        :init (sublimity-mode 1))
    #+end_src

*** Winner-mode
    Winner Mode is a global minor mode that allows you to “undo” and “redo” changes in WindowConfiguration. It is included in GNU Emacs, and documented as winner-mode.
    #+begin_src emacs-lisp
      (use-package winner
        :init (winner-mode)
        :general
        (+general-global-window
          "u" 'winner-undo
          "r" 'winner-redo))
    #+end_src

*** Pdf-tools
    #+begin_src emacs-lisp
      (use-package pdf-tools
        :straight t
        :init (pdf-loader-install)
        :hook (pdf-view-mode . (lambda ()
                                 (linum-mode -1)
                                 (display-line-numbers-mode -1)))
        (pdf-view-mode . auto-revert-mode))
    #+end_src

*** Sudo-edit
    Instead of installing the package, just add an interactive function to append the tramp string to the file name, adding the sudo-edit functionality.
    #+begin_src emacs-lisp
      (defun sudo-edit (&optional arg)
        "Edit currently visited file as root.

      With a prefix ARG prompt for a file to visit.
      Will also prompt for a file to visit if current
      buffer is not visiting a file."
        (interactive "P")
        (if (or arg (not buffer-file-name))
            (find-file (concat "/sudo:root@localhost:"
                               (ido-read-file-name "Find file(as root): ")))
          (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
#+end_src

*** Mac modifiers
    Emacs captures the right Meta key too, which makes writing with accented keys impossible. The fix for this is removing the behaviour of the right option modifier (Right Alt), which lets the OS capture the keypress.
    #+begin_src emacs-lisp
      (use-package emacs
        :custom (mac-right-option-modifier 'none))
    #+end_src

*** Encoding system
    #+begin_src emacs-lisp
      (prefer-coding-system 'utf-8)
      (set-default-coding-systems 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (if (boundp 'buffer-file-coding-system)
          (setq-default buffer-file-coding-system 'utf-8)
        (setq default-buffer-file-coding-system 'utf-8))

      ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
      (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
    #+end_src

*** Isearch
    #+begin_quote
    Isearch stands for incremental search. This means that search results are updated and highlighted while you are typing your query, incrementally.
    #+end_quote
    Using the config from angrybacon: [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#navigation-search][dotemacs/dotemacs.org at master · angrybacon/dotemacs · GitHub]]
    #+begin_src emacs-lisp
      (use-package isearch
        :hook (isearch-update-post . ab/isearch-aim-beginning)
        :custom (isearch-allow-scroll t)
        :preface
        (defun ab/isearch-aim-beginning ()
          "Move cursor back to the beginning of the current match."
          (when (and isearch-forward (number-or-marker-p isearch-other-end))
            (goto-char isearch-other-end))))
    #+end_src

*** Expand-region
    Expand region increases the selected region by semantic units. Just keep pressing the key until it selects what you want.
    #+begin_src emacs-lisp
      (pending-delete-mode)
      (use-package expand-region
        :straight t
        :bind ("C-=" . er/expand-region))
    #+end_src

*** Password manager
    Instead of using the default authinfo password manager, which defaults to the =.authinfo.gpg= file, configure Emacs to use [[https://www.passwordstore.org/][Pass: The Standard Unix Password Manager]].
    #+begin_src emacs-lisp
      (use-package auth-source-pass
        :init (auth-source-pass-enable))
    #+end_src

    The previous snippet configures Emacs to be able to access the gpg files when a password is required. There is also a pass major mode to insert and copy passwords from Emacs.
    #+begin_src emacs-lisp
      (use-package pass
        :straight t
        :commands pass
        :custom (pass-username-field "login"))
    #+end_src

*** Keep emacs clean
    This is the section created with the intention of make emacs create the files needed, but keep
    the directories clean, saving the backup files in set locations.

**** Warnings
     There are some warnings that need to be supressed, as they happen on startup, according to some of the code of the packages. There is nothing else to do.
     #+begin_src emacs-lisp
       (use-package emacs
         :custom (ad-redefinition-action 'accept))
     #+end_src

**** No-littering
     No littering is a package which is used with intention of keeping the generated
     files by emacs to a minimum, by changing the path where all of the files are stored,
     being by default the current directory.
     #+begin_src emacs-lisp
       (use-package no-littering
         :straight t)
     #+end_src
**** Backup files
     Files created with the tilde extension, used to track changes to files, being able to 
     recover them on system crash.
     #+begin_src emacs-lisp
       (setq backup-directory-alist `(("." . ,(no-littering-expand-var-file-name "backups/"))))
     #+end_src

**** Auto save files
     Files created when you haven't saved a file yet.
     #+begin_src emacs-lisp
       (setq auto-save-list-file-prefix (no-littering-expand-var-file-name "auto-saves/sessions/")
             auto-save-file-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-saves/") t)))
     #+end_src

***** auto-save on focus change
      Xah-lee on his blog [[http://ergoemacs.org/emacs/emacs_auto_save.html][Ergoemacs]] talks about saving all the unsaved files when the focus is changed from the frame, which seems like a clever solution and it doesn't really hurt to have.
      #+begin_src emacs-lisp
        (use-package emacs
          :init
          (defun xah/save-all-unsaved ()
            "Save all unsaved files. no ask."
            (interactive)
            (save-some-buffers t))
          :config
          (add-function :after after-focus-change-function #'xah/save-all-unsaved))
      #+end_src

**** Lockfiles and versions
     configuration of lockfiles and version control for files,
     the intention this modification is the clean workspace directories.
     #+begin_src emacs-lisp
       (setq
        create-lockfiles nil
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)
     #+end_src
*** Default bindings
    There are some awful keybindings that Emacs binds by default. These better defaults try to give a little more user-friendly keybindings, while maintaining the original Emacs essence.
    #+begin_src emacs-lisp
      (use-package dabbrev
        ;; Swap M-/ and C-M-/
        :bind (("M-/" . dabbrev-completion)
               ("C-M-/" . dabbrev-expand)))
    #+end_src

*** Bookmark faces
    By default, there is a horrible bookmark face that has been defined in Emacs 28. I don’t really find the need to have a bookmark face, which dirties the org-mode buffers.
    #+begin_src emacs-lisp
      (use-package emacs
        :custom-face (bookmark-face ((t nil))))
    #+end_src

*** Delimiters
**** smart-parens
     Smart-parens is a package that improves on the previous package,
     now deprecated: autopair. Smart-parens has the plus of being maintained,
     considering that they usually merge pull requests and responde to issues.
     #+begin_src emacs-lisp :tangle no
       (use-package smartparens
         :straight t
         :hook (prog-mode . smartparens-mode))

       (use-package smartparens-config
         :after smartparens)
     #+end_src

**** rainbow-delimiters
     In order to be able to differentiate the parenthesis in all programming
     modes, rainbow-delimiters considers different faces from your current theme
     and adds the same face to the matching parens.

     #+begin_src emacs-lisp
       (use-package rainbow-delimiters
         :straight t
         :hook (prog-mode . rainbow-delimiters-mode)
         :custom-face
         (rainbow-delimiters-base-error-face
          ((t (:foreground "#fc0303" :inherit nil))))
         (rainbow-delimiters-mismatched-face
          ((t (:foreground "#fc0303" :inherit nil))))
         (rainbow-delimiters-unmatched-face
          ((t (:foreground "#fc0303" :inherit nil)))))
     #+end_src

*** Modeline
**** Doom-modeline
     #+begin_src emacs-lisp
       (defvar doom-modeline-icon (display-graphic-p)
         "Whether show `all-the-icons' or not.

               Non-nil to show the icons in mode-line.
               The icons may not be showed correctly in terminal and on Windows.")

       (defface egoge-display-time
         '((((type x w32 mac))
            (:inherit highlight))
           (((type tty))
            (:foreground "blue")))
         "Face used to display the time in the mode line.")

       (defface egoge-display-time
         '((((type x w32 mac))
            (:inherit highlight))
           (((type tty))
            (:foreground "blue")))
         "Face used to display the time in the mode line.")
       (setq display-time-string-forms
             '((propertize (concat " " 24-hours ":" minutes " ")
                           'face 'egoge-display-time)))
       (display-time-mode 1)
       (display-time-update)

       (use-package doom-modeline
         :straight t
         :custom
         (doom-modeline-mu4e t)
         (doom-modeline-icon t)
         (doom-modeline-project-detection 'project)
         (doom-modeline-modal-icon nil)
         (doom-modeline-window-width-limit fill-column)
         (display-time-string-forms
          '((propertize (concat " " 24-hours ":" minutes " ")
                        'face 'egoge-display-time)))
         :hook (after-init . doom-modeline-mode)
         :config
         (display-time-mode)
         (display-time-update))
     #+end_src

**** All-the-icons
     #+begin_src emacs-lisp
       (use-package all-the-icons
         :straight t)
     #+end_src

*** Commenting
**** Smart comments
     When at the end of the line, creates a end-line comment.
     When at the beginning or middle of the line, comments line.
     When pointing at region, comments full region.

     Custom function created with the intention of using the commented
     lines in order to make sure that we are not forgetting any additional
     code. I used to have a package that did all of the comment stuff, but
     it seems to have been deprecated.
     #+begin_src emacs-lisp
       (use-package smart-comment
         :straight t
         :preface
         (defun dr/copy-and-comment-region (beg end &optional arg)
           "Duplicate the region and comment-out the copied text.
                See `comment-region' for behavior of a prefix arg."
           (interactive "r\nP")
           (copy-region-as-kill beg end)
           (goto-char end)
           (yank)
           (comment-region beg end arg))
         :general
         (general-def 'motion
           "gc" '(nil :which-key "comment")
           "gcc" 'smart-comment
           "gcy" 'dr/copy-and-comment-region)
         :bind ("M-;" . smart-comment))
     #+end_src
     
*** Buffers
**** Visiting-buffer
     #+begin_quote
     I often want to both delete a file and kill the buffer it's open in. I thought of writing a simple command to do that, but then realized I basically never want to delete the file and keep the buffer open. So instead, I'm advising delete-file so that if it is called interactively (i.e., I called the command directly, not that some Emacs Lisp called it), it also kills a buffer visiting the file if there is one.

     Similarly, I advise rename-file so that if it is called interactively, it also renames any visiting buffer. And additionally for Emacs Lisp libraries it handles updating the (provide 'library-name) form and the ;;; library-name.el comments you often find at top and bottom.
     #+end_quote
     Oantolin - [[https://www.reddit.com/r/emacs/comments/p6mwx2/weekly_tips_tricks_c_thread/h9fclek?utm_source=share&utm_medium=web2x&context=3][link]]

     I added the =visiting-buffer.el= file to my /lisp dir, and use-packaged the call. The =:demand t= clause is required, as I have set =use-package-always-defer= to =t=.
     #+begin_src emacs-lisp
       (use-package visiting-buffer
         :demand t)
     #+end_src

*** Directories
**** Dired
     Dired is the "package" that gives us all the functionality to a dired buffer which in essence is the same as the output of ls. 
     #+begin_src emacs-lisp
       (use-package dired
         :custom 
         (dired-listing-switches "-aBhl")
         (dired-use-ls-dired nil)
         :bind (:map dired-mode-map 
                     ("b" . dired-up-directory)))
     #+end_src

**** Backup directory
     #+begin_src emacs-lisp
       (setq backup-directory-alist '(("" . "~/.emacs.d/backup")))
     #+end_src

**** Dired-subtree
     This package defines function dired-subtree-insert which instead inserts the subdirectory directly below its line in the original listing, and indent the listing of subdirectory to resemble a tree-like structure (somewhat similar to tree(1) except the pretty graphics). The tree display is somewhat more intuitive than the default "flat" subdirectory manipulation provided by =i=.
     #+begin_src emacs-lisp
       (use-package dired-subtree
         :straight t
         :after dired
         :custom (dired-subtree-use-backgrounds nil)
         :bind (:map dired-mode-map
                     ("<tab>" . dired-subtree-toggle)
                     ("<C-tab>" . dired-subtree-cycle)
                     ("<backtab>" . dired-subtree-remove)))
     #+end_src
     
*** Help
    The default emacs help buffers could use some tweaking, and the Helpful package is there to assist. It provides better formatting and links for help buffers, and defines different functions to limit the disruption effect in your emacs configuration.
    #+begin_src emacs-lisp 
      (use-package helpful
        :straight t
        :general
        (global-definer
          "h" 'qk/help-transient)
        :config
        (straight-use-package 'transient)
        (transient-define-prefix qk/help-transient ()
                                 "Help commands that I use. A subset of C-h with others thrown in."
                                 ["Help Commands"
                                  ["Mode & Bindings"
                                   ("m m" "Mode" describe-mode)
                                   ("m w" "Where Is" where-is)
                                   ]
                                  ["Describe"
                                   ("d C" "Command" helpful-command)
                                   ("d f" "Function" helpful-function)
                                   ("d v" "Variable" helpful-variable)
                                   ("d m" "Macro" helpful-macro)
                                   ("d k" "Key" helpful-key)
                                   ]
                                  ["Info on"
                                   ("C-c" "M-x function" Info-goto-emacs-command-node)
                                   ("C-k" "Emacs Key" Info-goto-emacs-key-command-node)
                                   ]
                                  ]
                                 [
                                  ["Internals"
                                   ("i I" "Input Method" describe-input-method)
                                   ("i G" "Language Env" describe-language-environment)
                                   ("i S" "Syntax" describe-syntax)
                                   ("i O" "Coding System" describe-coding-system)
                                   ("i C-o" "Coding Brief" describe-current-coding-system-briefly)
                                   ("i T" "Display Table" describe-current-display-table)
                                   ("i e" "Echo Messages" view-echo-area-messages)
                                   ("i l" "Lossage" view-lossage)
                                   ]
                                  ["DWIM"
                                   ("." "At Point   " helpful-at-point)
                                   ]
                                  ["Info Manuals"
                                   ("i RET" "Info" info)
                                   ("4" "Other Window " info-other-window)
                                   ("C-e" "Emacs" info-emacs-manual)
                                   ]
                                  ]))
    #+end_src

*** Latex
    Adding general configuration for tex files and latex-mode better defaults.
    #+begin_src emacs-lisp
      (use-package tex
        :straight auctex
        :mode ("\\.tex\\'" . latex-mode)
        :hook (latex-mode . (lambda ()
                              (reftex-mode t)
                              (flyspell-mode t))))
    #+end_src

    Removing the mark keybindings on latex buffers, which are
    normally bound to the flyspell word correction keys.
    #+begin_src emacs-lisp
      (use-package flyspell
        :general
        (+general-global-toggle
         "f" '(nil :which-key "flyspell")
         "fm" 'flyspell-mode
         "fd" 'ispell-change-dictionary)
        :bind (:map flyspell-mode-map (("C-." . nil)
                                       ("C-," . nil))))
    #+end_src

**** Custom latex classes
     I add a custom latex class for exporting my essays and class asignments.
     #+begin_src emacs-lisp
       (defvar org-export-output-directory-prefix "export_"
         "prefix of directory used for org-mode export")

       (defadvice org-export-output-file-name (before org-add-export-dir activate)
         "Modifies org-export to place exported files in a different directory"
         (when (not pub-dir)
           (setq pub-dir (concat org-export-output-directory-prefix (substring extension 1)))
           (when (not (file-directory-p pub-dir))
             (make-directory pub-dir))))

       (use-package ox-latex
         :custom
         (org-latex-hyperref-template "\\hypersetup{\n pdfauthor={%a},\n pdftitle={%t},\n pdfkeywords={%k},\n pdfsubject={%d},\n pdfcreator={%c}, \n pdflang={%L}, colorlinks=true, \n linkcolor=blue, urlcolor=blue}\n")
         (org-latex-toc-command "\\tableofcontents\n\\newpage")
         (org-latex-listings nil)
         (org-latex-pdf-process   '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
         :config
         (add-to-list 'org-latex-packages-alist '("" "color"))
         (add-to-list 'org-latex-packages-alist '("" "listings"))
         (add-to-list 'org-latex-classes
                      '("assignment"  "\\documentclass[titlepage]{article}\n\\usepackage[left=4cm,right=4cm,bottom=1in]{geometry}\n\\addtolength{\\textwidth}{4cm}\n\\addtolength{\\hoffset}{-2cm}\n\\topmargin -1cm\n\\usepackage[AUTO]{babel}"
                        ("\\section{%s}" . "\\section*{%s}")
                        ("\\subsection{%s}" . "\\subsection*{%s}")
                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                        ("\\paragraph{%s}" . "\\paragraph*{%s}")
                        ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
     #+end_src

*** Appearence
**** Cursor display
     Bar cursor instead of rectangle default.
     #+begin_src emacs-lisp
       (setq-default cursor-type 'bar)
     #+end_src

**** Yes/No with y/n
     #+begin_src emacs-lisp
       (fset 'yes-or-no-p 'y-or-n-p)
     #+end_src

**** Splash screen and startup message
     #+begin_src emacs-lisp
       (setq inhibit-startup-message t)
     #+end_src

**** Line numeration on left side
     #+begin_src emacs-lisp
       (use-package display-line-numbers
         :preface
         (defcustom display-line-numbers-exempt-modes
           '(vterm-mode eshell-mode shell-mode term-mode ansi-term-mode pdf-view-mode)
           "Major modes on which to disable line numbers."
           :group 'display-line-numbers
           :type 'list
           :version "green")

         (defun display-line-numbers--turn-on ()
           "Turn on line numbers except for certain major modes.
       Exempt major modes are defined in `display-line-numbers-exempt-modes'."
           (unless (or (minibufferp)
                       (member major-mode display-line-numbers-exempt-modes))
             (display-line-numbers-mode))))

       (use-package emacs
         :custom (display-line-numbers 'relative)
         :config
         (put 'erase-buffer 'disabled nil))
     #+end_src

**** New lines
     Adding newline at the end of the file.
     #+begin_src emacs-lisp
       (setq next-line-add-newlines t)    
     #+end_src

**** Sounds
     Disabling beep sound.
     #+begin_src emacs-lisp
       (setq visible-bell nil)
       (setq ring-bell-function 'ignore)
     #+end_src

**** Menu-bar
     Disabling the menu-bar, prior to tab-mode-line configuration.
     #+begin_src emacs-lisp
       (menu-bar-mode -1)
     #+end_src

*** Indentation
    Indentation to 4 spaces instead of tab.
    #+begin_src emacs-lisp
      (setq-default indent-tabs-mode nil)
      (setq-default tab-width 4)
    #+end_src

*** Markdown
    Markdown configuration, which I use specially often when editing README files
    on Github. The are some interesting options like the change of the markdown-command
    to pandoc which is way better at compiling html5. 
    #+begin_src emacs-lisp
      (use-package markdown-mode
        :mode ("\\.md\\'" . gfm-mode)
        :commands (markdown-mode gfm-mode)
        :custom (markdown-command "pandoc -t html5")
        :hook 
        (markdown-mode . toc-org-mode)
        (markdown-mode . visual-line-mode))
    #+end_src

*** Mark commands
    Adding better defaults to the mark commands, as I find cumbersome to remove the
    region everytime I want to access the mark functionality.

    #+begin_src emacs-lisp
      (defun push-mark-no-activate ()
        "Pushes `point' to `mark-ring' and does not activate the region
         Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
        (interactive)
        (push-mark (point) t nil)
        (message "Pushed mark to ring"))

      (defun jump-to-mark ()
        "Jumps to the local mark, respecting the `mark-ring' order.
        This is the same as using \\[set-mark-command] with the prefix argument."
        (interactive)
        (set-mark-command 1))

      (defun exchange-point-and-mark-no-activate ()
        "Identical to \\[exchange-point-and-mark] but will not activate the region."
        (interactive)
        (exchange-point-and-mark)
        (deactivate-mark nil))

      (global-set-key (kbd "C-.") 'push-mark-no-activate)
      (global-set-key (kbd "C-,") 'jump-to-mark)
      (define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
    #+end_src

*** Perspective.el
    The Perspective package provides multiple named workspaces (or "perspectives") in Emacs, similar to multiple desktops in window managers like Awesome and XMonad, and Spaces on the Mac. Each perspective has its own buffer list and its own window layout, along with some other isolated niceties, like the xref ring.
    #+begin_src emacs-lisp
      (use-package perspective
        :straight t
        :bind
        ("C-x x s" . persp-switch)
        ("s-]" . persp-next)
        ("s-[" . persp-prev)
        :custom
        (persp-sort 'created)
        (persp-state-default-file (concat persp-save-dir "persp-save-state.el"))
        (persp-initial-frame-name "agenda")
        :config (persp-mode))
    #+end_src

*** Fill column
    #+begin_src emacs-lisp
      (setq-default fill-column 80)
    #+end_src

*** Auto indent
    #+begin_src emacs-lisp
      (define-key global-map (kbd "RET") 'newline-and-indent)
    #+end_src

*** Flyspelling
    Flyspelling is a process that checks the current buffer and highlights all
    the words that have been misspelled. This is key to good spelling in formal
    texts as well as blog post, or note making.
    #+begin_src emacs-lisp
      (defun fd-switch-dictionary()
        (interactive)
        (let* ((dic ispell-current-dictionary)
               (change (if (string= dic "english") "spanish" "english")))
          (ispell-change-dictionary change)
          (message "Dictionary switched from %s to %s" dic change)
          ))
      (defun flyspell-buffer-after-pdict-save (&rest _)
        (flyspell-buffer))

      (advice-add 'ispell-pdict-save :after #'flyspell-buffer-after-pdict-save)
    #+end_src

*** Special characters
    There are some writing characters that are used in org-mode when exporting,
    but when trying to check the file's html, the -- is exported as two individual
    dashes, instead of the em-dash.
    #+begin_src emacs-lisp
      (defun help/real-insert (char)
        (cl-flet ((do-insert
                   () (if (bound-and-true-p org-mode)
                          (org-self-insert-command 1)
                        (self-insert-command 1))))
          (setq last-command-event char)
          (do-insert)))
      (defun help/insert-em-dash ()
        "Insert a EM-DASH.
      - \"best limited to two appearances per sentence\"
      - \"can be used in place of commas to enhance readability.
         Note, however, that dashes are always more emphatic than
         commas\"
      - \"can replace a pair of parentheses. Dashes are considered
         less formal than parentheses; they are also more intrusive.
         If you want to draw attention to the parenthetical content,
         use dashes. If you want to include the parenthetical content
         more subtly, use parentheses.\"
        - \"Note that when dashes are used in place of parentheses,
           surrounding punctuation should be omitted.\"
      - \"can be used in place of a colon when you want to emphasize
         the conclusion of your sentence. The dash is less formal than
         the colon.\"
      - \"Two em dashes can be used to indicate missing portions of a
         word, whether unknown or intentionally omitted.\"
        - \"When an entire word is missing, either two or three em
           dashes can be used. Whichever length you choose, use it
           consistently throughout your document. Surrounding punctuation
           should be placed as usual.\"
      - \"The em dash is typically used without spaces on either side,
         and that is the style used in this guide. Most newspapers,
         however, set the em dash off with a single space on each side.\"
      Source: URL `https://www.thepunctuationguide.com/em-dash.html'"
        (interactive)
        (help/real-insert ?—))
      (defun help/insert-en-dash ()
        "Insert a EN-DASH.
      - \"is used to represent a span or range of numbers, dates,
         or time. There should be no space between the en dash and
         the adjacent material. Depending on the context, the en
         dash is read as “to” or “through.”\"
        - \"If you introduce a span or range with words such as
           'from' or 'between', do not use the en dash.\"
      - \"is used to report scores or results of contests.\"
      - \"an also be used between words to represent conflict,
         connection, or direction.\"
      - \"When a compound adjective is formed with an element that
         is itself an open compound or hyphenated compound, some
         writers replace the customary hyphen with an en dash. This
         is an aesthetic choice more than anything.
      Source: URL `https://www.thepunctuationguide.com/en-dash.html'"
        (interactive)
        (help/real-insert ?–))
      (defun help/insert-hyphen ()
        "Insert a HYPHEN
      - \"For most writers, the hyphen’s primary function is the
         formation of certain compound terms. The hyphen is also
         used for word division [in typesetting].
      - \"Compound terms are those that consist of more than one
         word but represent a single item or idea.\"
      Source: URL `https://www.thepunctuationguide.com/hyphen.html'"
        (interactive)
        (help/real-insert ?-))
    #+end_src

**** Euro symbol
     Bind the euro symbol to an easy to reach command.
     #+begin_src emacs-lisp
       (defun qk/insert-euro-symbol ()
         (interactive)
         (help/real-insert ?€))

       (use-package emacs
         :bind ("C-c e" . qk/insert-euro-symbol))
     #+end_src

*** Typo
    Typo.el mode is a mode to change the default behaviour of special character pressing, like ", ' or more.
    #+begin_src emacs-lisp
      (use-package typo
        :straight t
        :general
        (+general-global-toggle
          "t" 'typo-mode))
    #+end_src

*** Browse-url
    Browse url is the package that controls the information that is passed to the browser when forwarded from emacs. I find that cookies are important when accessing chrome, might need to check again if I can select to save cookies only for Chrome browsing.

    #+begin_src emacs-lisp
      (use-package browse-url
        :commands (browse-url browse-url-firefox)
        :custom
        (url-cookie-file (no-littering-expand-var-file-name "cookies/cookies")))
    #+end_src

*** Whole-line-or-region
    Emacs doesn't have a by default command to get the whole region without going to the beginning of the line and marking the rest of the line or pressing C-S-backspace to remove the whole line.

    Whole-line-or-region implementes some changes to add the mentioned funcionality. Using the remapped C-w and M-w (cut and copy) without a region selected with select the whole line.
    #+begin_src emacs-lisp
      (use-package whole-line-or-region
        :straight t
        :init (whole-line-or-region-global-mode))
    #+end_src

*** Undo-tree
    Instead of treating undo/redo as a linear sequence of changes, undo-tree-mode treats undo history as a branching tree of changes, similar to the way Vim handles it. This makes it substantially easier to undo and redo any change, while preserving the entire history of past states.
    #+begin_src emacs-lisp
      (use-package undo-tree
        :straight t
        :demand t
        :config (global-undo-tree-mode 1))
    #+end_src

** Window switching
   I'm trying ace-window in order to allow faster window switching, when working with
   multiple buffers in the same frame. Disabling also the undo command, trying to get
   used to C-/
   #+begin_src emacs-lisp
     (use-package ace-window
       :straight t
       :bind
       ("M-o" . qk/stop-using-emacs-bindings)
       ("C-x o" . qk/stop-using-emacs-bindings)
       :general
       (+general-global-window
         "o" 'ace-window)
       :custom
       (aw-keys '(?h ?j ?k ?l ?a ?s ?d ?f ?g))
       (aw-background nil))
   #+end_src

** Completion framework
*** Modular completion
    Instead of having an abstracted and heavy completion framework, I find that configuring your own makes the process simpler and lighter, focusing on the information that you really need in your configuration, removing all additional commands.

**** Vertico
     Vertico provides a minimalistic vertical completion UI, which is based on the default completion system. By reusing the default system, Vertico achieves full compatibility with built-in Emacs commands and completion tables. Vertico is pretty bare-bone and comes with only a minimal set of commands. The code base is small (~500 lines of code without whitespace and comments). Additional enhancements can be installed separately via complementary packages.
     #+begin_src emacs-lisp
       (use-package vertico
         :straight t
         :init (vertico-mode)
         :custom (vertico-cycle t))
     #+end_src

**** Orderless
     Orderless is one of the same emacs packages that works modularly, using the basic emacs API. This package provides an orderless completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order. Each component can match in any one of several ways: literally, as a regexp, as an initialism, in the flex style, or as multiple word prefixes. By default, regexp and literal matches are enabled.
     #+begin_src emacs-lisp
       (use-package orderless
         :straight t
         :custom
         (completion-styles '(orderless))
         (completion-category-defaults nil)
         (completion-category-overrides '((file (styles . (partial-completion))))))
     #+end_src

**** Savehist
     Savehist is a built in package thar persistes the completion candidates through Emacs restarts. Vertico then can sort by history position.
     #+begin_src emacs-lisp
       (use-package savehist
         :init
         (savehist-mode))
     #+end_src

**** Recentf-mode
     Recentf-mode needs to be enabled in order to save the history of the files and use them later as virtual buffers. This is a great package (which is already built-in) combined with savehist, as savehist saves the completion candidates but not the files on which the candidates are.
     #+begin_src emacs-lisp
       (use-package recentf
         :init (recentf-mode))
     #+end_src
     
**** Additional completion configuration
     Adding a prompt indicator that the completing-read-multiple command is enabled. The other configuration is enabling recursive minibuffers. I also disabled the cursor in the minibuffer prompt, avoid clicking by accident.
     #+begin_src emacs-lisp
       (use-package emacs
         :init
         ;; Add prompt indicator to `completing-read-multiple'.
         (defun crm-indicator (args)
           (cons (concat "[CRM] " (car args)) (cdr args)))
         (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

         ;; Do not allow the cursor in the minibuffer prompt
         (setq minibuffer-prompt-properties
               '(read-only t cursor-intangible t face minibuffer-prompt))
         (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

         ;; Enable recursive minibuffers
         (setq enable-recursive-minibuffers t))
     #+end_src

**** Marginalia
     Marginalia are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations placed at the margin of the minibuffer for your completion candidates. Marginalia can only add annotations to be displayed with the completion candidates. It cannot modify the appearance of the candidates themselves, which are shown as supplied by the original commands.
     #+begin_src emacs-lisp
       (use-package marginalia
         :straight t
         :init (marginalia-mode)
         :config
         (add-to-list 'marginalia-prompt-categories '("tab by name" . tab)))
     #+end_src

**** Consult
     Consult provides various practical commands based on the Emacs completion function completing-read, which allows to quickly select an item from a list of candidates with completion. Consult offers in particular an advanced buffer switching command consult-buffer to switch between buffers and recently opened files. Multiple search commands are provided, an asynchronous consult-grep and consult-ripgrep, and consult-line, which resembles Swiper. Some of the Consult commands are enhanced versions of built-in Emacs commands. For example the command consult-imenu presents a flat list of the Imenu with live preview and narrowing support.
     #+begin_src emacs-lisp
       (use-package consult
         :straight t
         :bind (;; C-x bindings (ctl-x-map)
                ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
                ;; ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
                ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
                ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
                ;; Other custom bindings
                ("M-y" . consult-yank-pop)                ;; orig. yank-pop
                ;; M-g bindings (goto-map)
                ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
                ("M-g g" . consult-goto-line)             ;; orig. goto-line
                ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
                ("M-g o" . consult-outline)
                ("M-g m" . consult-mark)
                ("M-g k" . consult-global-mark)
                ("M-g i" . consult-imenu)
                ("M-g I" . consult-project-imenu)
                ;; M-s bindings (search-map)
                ("M-s f" . consult-fd) ;; Changed on the `affe' configuration.
                ("M-s L" . consult-locate)
                ("M-s g" . consult-grep) ;; Changed on the `affe' configuration.
                ("M-s G" . consult-git-grep)
                ("M-s r" . consult-ripgrep)
                ("M-s l" . consult-line)
                ("M-s m" . consult-multi-occur)
                ("M-s k" . consult-keep-lines)
                ("M-s u" . consult-focus-lines)
                ;; Isearch integration
                ("M-s e" . consult-isearch)
                :map isearch-mode-map
                ("M-e" . consult-isearch)                 ;; orig. `isearch-edit-string'
                ("M-s e" . consult-isearch)               ;; orig. `isearch-edit-string'
                ("M-s l" . consult-line))
         :general
         (+general-global-file
           "r" 'consult-recent-file)
         (+general-global-search
          "l" 'consult-line)
         ;; The :init configuration is always executed (Not lazy)
         :init
         (setq register-preview-delay 0
               register-preview-function #'consult-register-format)
         (advice-add #'register-preview :override #'consult-register-window)
         ;; Use Consult to select xref locations with preview
         (setq xref-show-xrefs-function #'consult-xref
               xref-show-definitions-function #'consult-xref)
         :custom
         (consult-narrow-key "<")
         (consult-preview-key nil)
         :config
         (consult-customize
          ;; Set preview for `consult-buffer' to key `M-.'n
          consult-buffer :preview-key (kbd "M-."))
         :preface
         (defun consult-fd (&optional dir initial)
           (interactive "P")
           (let ((consult-find-command "fdfind --color=never --full-path ARG OPTS"))
             (consult-find dir initial))))
     #+end_src

***** Consult-projectile
      Consult-projectile is a package that is still in development, adding this here only means I'm interested in having something of the sort. I might need to do a more in-depth search a few weeks forward.
      #+begin_src emacs-lisp
        (use-package consult-projectile
          :straight (consult-projectile :type git :host gitlab :repo "OlMon/consult-projectile" :branch "master")
          :general (+general-global-project
                    "f" 'consult-projectile))
      #+end_src

***** Consult-lsp
      Helm and Ivy users have extra commands that leverage lsp-mode extra information, let’s try to mimic a few features of helm-lsp and lsp-ivy in consult workflow. =consult-lsp= adds the two following functions: =consult-lsp-diagnostics= and =consult-lsp-symbols=, which can be bound to default lsp-mode-map commands.
      #+begin_src emacs-lisp
        (use-package consult-lsp
          :straight t
          :bind (:map lsp-mode-map
                      ([remap xref-find-apropos] . consult-lsp-symbols)))
      #+end_src

**** Embark
     This package provides a sort of right-click contextual menu for Emacs, accessed through the embark-act command (which you should bind to a convenient key), offering you relevant actions to use on a target determined by the context:

     - In the minibuffer, the target is the current best completion candidate.
     - In the *Completions* buffer the target is the completion at point.
     - In a regular buffer, the target is the region if active, or else the file, symbol or URL at point.
     #+begin_src emacs-lisp
       (use-package embark
         :straight t
         :bind
         (("C-;" . embark-act)
          :map embark-file-map
          ("s" . embark-magit-status)
          :map minibuffer-local-map
          ("M-o" . embark-act))
         :init
         (defun embark-magit-status (file)
           "Run `magit-status` on repo containing the embark target."
           (interactive "GFile: ")
           (magit-status (locate-dominating-file file ".git")))
         (require 'consult)
         (defun oa/select-tab-by-name (tab)
           (interactive
            (list
             (let ((tab-list (or (mapcar #'(lambda (tab) (cdr (assq 'name tab)))
                                         (tab-bar-tabs))
                                 (user-error "No tabs found"))))
               (consult--read tab-list
                              :prompt "Tabs: "
                              :category 'tab))))
           (tab-bar-select-tab-by-name tab))

         ;; Optionally replace the key help with a completing-read interface
         (setq prefix-help-command #'embark-prefix-help-command)
         :config
         ;; Hide the mode line of the Embark live/completions buffers
         (add-to-list 'display-buffer-alist
                      '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                        nil
                        (window-parameters (mode-line-format . none))))
         (embark-define-keymap embark-tab-actions
                               "Keymap for actions for tab-bar tabs (when mentioned by name)."
                               ("s" oa/select-tab-by-name)
                               ("r" tab-bar-rename-tab-by-name)
                               ("k" tab-bar-close-tab-by-name))

         (add-to-list 'embark-keymap-alist '(tab . embark-tab-actions)))

       (use-package tab-bar
         :custom
         (tab-bar-close-button-show nil)
         (tab-bar-new-button-show nil)
         (tab-bar-show nil)
         :bind
         ("C-x t RET" . oa/select-tab-by-name))
     #+end_src

***** Embark-consult
      Configuration merging embark and consult, creating live previews of completion candidates in the Embark collections buffer.
      
      #+begin_src emacs-lisp
        (use-package embark-consult
          :straight t
          :after (embark consult)
          :demand t
          :hook
          (embark-collect-mode . consult-preview-at-point-mode))
      #+end_src

** Hydra
   This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.
      #+begin_src emacs-lisp
        (use-package hydra
          :straight t
          :commands (defhydra defhydra+)
          :hook
          (embark-collect-mode . consult-preview-at-point-mode))
      #+end_src

** Terminal
   Configuration related to terminal emulators and modes. Recently, 
   I started using vterm which is faster than any of the others.

*** Eshell
    I'm trying out Eshell, since it seems it works a lot better in Emacs than =vterm=.
    #+begin_src emacs-lisp
      (use-package eshell
        ;; :bind (:map global-map
        ;;             ("C-c x" . eshell-toggle))
        :init
        (defun eshell-toggle ()
          "Toggle between eshell buffers.
      If you are in a shell buffer, switch the window configuration
      back to your code buffers.  Otherwise, create at least one shell
      buffer if it doesn't exist already, and switch to it.  On every
      toggle, the current window configuration is saved in a register."
          (interactive)
          (if (eq major-mode 'eshell-mode)
              (jump-to-register ?W)
            ;; Save current window config and jump to shell
            (window-configuration-to-register ?W)
            (condition-case nil
                (jump-to-register ?Z)
              (error
               (eshell)
               (when (= (length (window-list)) 2)
                 (other-window 1)
                 (eshell 1)
                 (other-window 1))))
            (window-configuration-to-register ?Z))))
    #+end_src

** Org-mode
*** Initial configuration
    Initial configuration of org-directory and refile.org, with the
    intention of all capture created items to go there before correct refiling.
    #+begin_src emacs-lisp
      (setq org-roam-directory "~/Documents/slipbox")
      (setq org-roam-v2-ack t)
      (use-package org
        :defer 2
        :bind (:map global-map
                    ("C-c o l" . org-store-link)
                    ("C-c a" . org-agenda)
                    ("C-c c" . org-capture)
                    :map org-mode-map
                    ("C-," . nil)
                    ("C-c o t" . org-babel-tangle))
        :general
        (major-mode-definer
          :major-modes '(org-mode)
          :keymaps '(org-mode-map)
          "c" 'org-capture
          "d" 'org-deadline
          "e" 'org-export-dispatch
          "s" 'org-schedule
          "t" '(nil :which-key "todo/tangle")
          "tt" 'org-todo
          "ta" 'org-babel-tangle
          "r" 'org-refile)
        (minor-mode-definer
          :keymaps 'org-capture-mode
          "f" 'org-capture-finalize
          "c" '(org-capture-kill :which-key "org-capture cancel")
          "r" 'org-capture-refile)
        :custom
        (org-directory "~/Documents/org_files")
        (org-return-follows-link t)
        (org-default-notes-file (concat org-roam-directory "/pages/refile.org"))
        (org-agenda-files (list (concat org-directory "/org-agenda")))
        (org-archive-location (concat org-directory "/archive/%s_archive::"))
        (org-refile-targets (quote ((nil :maxlevel . 5)
                                    (org-agenda-files :maxlevel . 5)
                                    (org-book-list-file :maxlevel . 2))))
        (org-src-fontify-natively t)
        (org-columns-default-format "%50ITEM(Task) %10Effort{:} %10CLOCKSUM")
        (org-clock-out-remove-zero-time-clocks t)
        (org-clock-out-when-done t)
        (org-agenda-restore-windows-after-quit t)
        (org-clock-persistence-insinuate t)
        (org-clock-persist t)
        (org-clock-in-resume t)
        (org-archive-file-header-format "#+FILETAGS: ARCHIVE\nArchived entries from file %s\n")
        :hook
        (org-capture-after-finalize . org-save-all-org-buffers)
        (org-clock-in-hook . org-save-all-org-buffers)
        (org-clock-out-hook . org-save-all-org-buffers)
        (org-mode . visual-line-mode)
        :config
        (defvar org-book-list-file (concat org-directory "/book_list.org")))
    #+end_src

**** org-insert-link DWIM
     I followed the [[https://xenodium.com/emacs-dwim-do-what-i-mean/][xenodium blog post]] talking about DWIM and its interactive commands already in Emacs. He implements his DWIM changes to to org-insert-link, and I found his changes to be interesting enough to add them to my own command.
     #+begin_src emacs-lisp
       (use-package org
         :preface
         (defun ar/org-insert-link-dwim ()
           "Like `org-insert-link' but with personal dwim preferences."
           (interactive)
           (let* ((point-in-link (org-in-regexp org-link-any-re 1))
                  (clipboard-url (when (string-match-p "^http" (current-kill 0))
                                   (current-kill 0)))
                  (region-content (when (region-active-p)
                                    (buffer-substring-no-properties (region-beginning)
                                                                    (region-end)))))
             (cond ((and region-content clipboard-url (not point-in-link))
                    (delete-region (region-beginning) (region-end))
                    (insert (org-make-link-string clipboard-url region-content)))
                   ((and clipboard-url (not point-in-link))
                    (insert (org-make-link-string
                             clipboard-url
                             (read-string "title: "
                                          (with-current-buffer (url-retrieve-synchronously clipboard-url)
                                            (dom-text (car
                                                       (dom-by-tag (libxml-parse-html-region
                                                                    (point-min)
                                                                    (point-max))
                                                                   'title))))))))
                   (t
                    (call-interactively 'org-insert-link)))))
         :general
         (major-mode-definer
           :major-modes '(org-mode)
           :keymaps '(org-mode-map)
           "l" 'ar/org-insert-link-dwim)
         :bind (:map org-mode-map
                     ("C-c C-l" . ar/org-insert-link-dwim)))
     #+end_src

**** org-fill-paragraph fix
     Org by default, when calling the fill-paragraph command breaks the org links, creating
     inconsistencies, specially when trying to export to html or other formats.

     I found some ways to fix this, getting input from a bug fix report from [[https://lists.gnu.org/archive/html/emacs-orgmode/2018-04/msg00105.html][Brent Goodrick]].
     #+begin_src emacs-lisp
       (defun bg-org-fill-paragraph-with-link-nobreak-p ()
         "Do not allow `fill-paragraph' to break inside the middle of Org mode links."
         (and (assq :link (org-context)) t))

       (defun bg-org-fill-paragraph-config ()
         "Configure `fill-paragraph' for Org mode."
         ;; Append a function to fill-nobreak-predicate similarly to how org-mode does
         ;; inside `org-setup-filling':
         (when (boundp 'fill-nobreak-predicate)
           (setq-local
            fill-nobreak-predicate
            (org-uniquify
             (append fill-nobreak-predicate
                     '(bg-org-fill-paragraph-with-link-nobreak-p))))))
       (add-hook 'org-mode-hook 'bg-org-fill-paragraph-config)
     #+end_src

*** Beautifying org-mode
    I find that org-mode default lacks some of the prose writing feeling
    when everything is organized, proportioned and just yours. Some of
    the following configuration tries to update the feeling of writing in
    org-mode.

    Starting with org-hide-emphasis-markers. Org-mode by default does not
    hide the markers used when trying to highlight with an specific mode.
    E.g *bold*, /italic/.
    #+begin_src emacs-lisp
      (setq org-hide-emphasis-markers t)
    #+end_src

    I always use "-" to delimit the lists, so change that to use the bullet
    point.
    #+begin_src emacs-lisp
      (font-lock-add-keywords 'org-mode
                              '(("^ *\\([-]\\) "
                                 (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    #+end_src
   
    Set up a proportional font for the headlines, configuring the :font and
    height face arguments.
    #+begin_src emacs-lisp
      (let* (;; (base-font-color     (face-foreground 'default nil 'default))
             (headline           `(:inherit default :weight bold)))

        (custom-theme-set-faces
         'user
         `(org-level-8 ((t (,@headline ))))
         `(org-level-7 ((t (,@headline ))))
         `(org-level-6 ((t (,@headline ))))
         `(org-level-5 ((t (,@headline ))))
         `(org-level-4 ((t (,@headline  :height 1.1))))
         `(org-level-3 ((t (,@headline  :height 1.15))))
         `(org-level-2 ((t (,@headline  :height 1.25))))
         `(org-level-1 ((t (,@headline  :height 1.5))))
         `(org-document-title ((t (,@headline  :height 1.75 :underline nil))))))
    #+end_src

    Change the default face for org-capture-mode-hook on the title, the giant header 1 level height feels awkward on the org-capture template modes.
    #+begin_src emacs-lisp
      (add-hook 'org-capture-mode-hook
                (lambda ()
                  (let* (;; (base-font-color     (face-foreground 'default nil 'default))
                         (headline           `(:inherit default :weight bold)))

                    (face-remap-add-relative 'org-level-1 '(,@headline)))))
    #+end_src

    Hide leading stars on org headlines, instead of using org-bullets. No need
    to have different symbols on the headlines, I'm just not used to it and it
    doesn't feel natural.
    #+begin_src emacs-lisp
      (setq org-hide-leading-stars t)
    #+end_src

*** Refiling
    Refiling setup, using the file name as header. Last line is
    so that we ensure that tasks cannot be tagged as completed
    before subtasks have been done so.
    #+begin_src emacs-lisp
      (defun qk/org-refile-target-verify-function ()
        "Function to be assigned to the `org-refile-target-verify-function'.
         Show only refile targets if they are tagged with PROJECT or the header
         that surrounds the current target is Items, which is a placeholder for
         either PROJECT items headings or non-PROJECT file targets."
        (or (string= (nth 2 (org-heading-components)) "PROJECT")
            (string= (nth 4 (org-heading-components)) "Items")))

      (use-package org
        :custom
        (org-refile-use-outline-path 'file)
        (org-outline-path-complete-in-steps nil)
        (org-refile-allow-creating-parent-nodes 'confirm)
        (org-enforce-todo-dependencies t)
        (org-refile-target-verify-function 'qk/org-refile-target-verify-function))
    #+end_src

    Adding keywords for easier refiling and capturing. Right side of
    the "|" key is used to indicate the keyword designing completion for
    a certain state.
    #+begin_src emacs-lisp
      (setq 
       org-todo-keywords
       (quote ((sequence "TODO(t)" "|" "DONE(d)")
               (sequence "PROJECT(p)" "|" "DONE(d)" "CANCELLED(c)")
               (sequence "WAITING(w)" "|")
               (sequence "|" "CANCELLED(c)")
               (sequence "|" "OPTIONAL(o)")
               (sequence "SOMEDAY(s)" "|" "CANCELLED(c)")
               (sequence "MEETING(m)" "|" "DONE(d)")
               (sequence "NOTE(n)" "|" "DONE(d)")
               )
              )

       )
    #+end_src

    Change the faces of the keywords, I keep it in a different source block to tangle or untagle if necessary.
    #+begin_src emacs-lisp
      (defface qk/meeting-todo-face '((t :weight bold))
        "Face to be changed by the `qk/choose-meeting-todo-face' function.")
      (defun qk/choose-meeting-todo-face ()
        "Depending on the theme change the MEETING todo-face. That face is too dark
      on dark themes, which I always have in my second index of the `qk/themes-list'"
        (if (equal qk/themes-index 0)
            (face-spec-set 'qk/meeting-todo-face '((t :foreground "#1874cd" :weight bold)) 'face-defface-spec)
          (face-spec-set 'qk/meeting-todo-face '((t :foreground "#81A1C1" :weight bold)) 'face-defface-spec)))
      (qk/choose-meeting-todo-face)

      (defun qk/set-org-todo-keyword-faces ()
        "Configure the MEETING org-todo-face and set up the others, which are still static."
        (qk/choose-meeting-todo-face)
        (setq org-todo-keyword-faces
            '(
              ("PROJECT" . (:foreground "#a87600" :weight bold))
              ("OPTIONAL" . (:foreground "#08a838" :weight bold))
              ("WAITING" . (:foreground "#fe2f92" :weight bold))
              ("CANCELLED" . (:foreground "#999999" :weight bold))
              ("SOMEDAY" . (:foreground "#ab82ff" :weight bold))
              ("MEETING" . qk/meeting-todo-face)
              ("NOTE" . (:foreground "#fcba03" :weight bold))
              )))
      (qk/set-org-todo-keyword-faces)

      (use-package emacs
        :hook (after-load-theme . qk/set-org-todo-keyword-faces))
    #+end_src

*** Org capture
    Capture templates are used with the intention of improving
    the workflow of adding several items and refiling.
    #+begin_src emacs-lisp
      (defvar org-blog-directory-file (concat org-directory "/blog/refile.org"))
      (setq
       org-capture-templates
       '(("t" "todo" entry (file+headline org-default-notes-file "Refile items")
          "* TODO %? :REFILING:\n%a\n" :clock-in t :clock-resume t)
         ("m" "Meeting/Interruption" entry (file+headline org-default-notes-file "Refile items")
          "* MEETING %? :REFILING:MEETING:\n" :clock-in t :clock-resume t)
         ("i" "Idea" entry (file+headline org-default-notes-file "Refile items")
          "* %? :REFILING:IDEA:\n" :clock-in t :clock-resume t)
         ("e" "Respond email" entry (file+headline org-default-notes-file "Refile items")
          "* TODO Write to %? on %? :REFILING:EMAIL: \nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
         ("s" "Someday" entry (file+headline org-default-notes-file "Refile items")
          "* SOMEDAY %? :REFILING:SOMEDAY:\n" :clock-in t :clock-resume t)
         ("p" "Project creation: @work or @home")
         ("pw" "@work Project entry" entry (file+headline org-default-notes-file "Refile items")
          "* PROJECT %? :@work:REFILING:PROJECT:\n" :clock-in t :clock-resume t)
         ("ph" "@home Project entry" entry (file+headline org-default-notes-file "Refile items")
          "* PROJECT %? :@home:REFILING:PROJECT:\n" :clock-in t :clock-resume t)
         ("o" "Optional item" entry (file+headline org-default-notes-file "Refile items")
          "* OPTIONAL %? :REFILING:OPTIONAL:\n" :clock-in t :clock-resume t)
         ("b" "Book" entry (file org-book-list-file)
          "* %^{TITLE}\n:PROPERTIES:\n:ADDED: %<[%Y-%02m-%02d]>\n:END:%^{AUTHOR}p\n%^{URL}p\n")
         ("n" "Note" entry (file+headline org-default-notes-file "Refile items")
          "* NOTE %? :REFILING:\n%a\n")
         ("B" "Blog post" entry (file org-blog-directory-file)
          "* TODO #+TITLE: \n#+DATE: \n#+CATEGORY: \n#+TAGS: \n#+SUMMARY: \n #+IMAGE: \n")
         )
       )
    #+end_src

*** Org agenda
**** Hiding tags 
    Adding hiding the tags on org agenda.
    #+begin_src emacs-lisp
      (use-package org-agenda
        :preface
        (defun qk/silently-open-agenda ()
          "Using the `with-silent-modifications' macro, open the agenda on the 'd' view
      which is the one that contains all the projects I follow."
          (interactive)
          (with-silent-modifications (org-agenda nil "d")))

        (defun qk/silently-open-todo-agenda ()
          "Using the `with-silent-modifications' macro, open the agenda on the 'a' view
      which is the one that contains the todos for the day/week."
          (interactive)
          (with-silent-modifications (org-agenda nil "a")))
        :general
        (+general-global-org
         "a" '(qk/silently-open-agenda :which-key "project agenda")
         "t" '(qk/silently-open-todo-agenda :which-key "day/week agenda")
         "c" 'org-capture
         "s" 'org-save-all-org-buffers
         "h" 'qk/org-capture-here)
        :custom
        (org-agenda-prefix-format "  %?-12t% s")
        (org-agenda-archives-mode nil)
        (org-agenda-skip-comment-trees nil)
        (org-agenda-skip-function nil)
        (org-agenda-hide-tags-regexp ".*")
        (org-roam-v2-ack t))
    #+end_src

**** Refiling workflow 
    Removing inherited and REFILING tags in order to use the tags correctly
    #+begin_src emacs-lisp
      (defun qk/org-remove-inherited-tag-strings ()
        "Removes inherited tags from the headline-at-point's tag string.
          Note this does not change the inherited tags for a headline,
          just the tag string."
        (org-set-tags (seq-remove (lambda (tag)
                                    (get-text-property 0 'inherited tag))
                                  (org-get-tags))))

      (defun qk/org-remove-refiling-tag ()
        "Remove the REFILING tag once the item has been refiled."
        (org-toggle-tag "REFILING" 'off))

      (defun qk/org-clean-tags ()
        "Visit last refiled headline and remove inherited tags from tag string."
        (save-window-excursion
          (org-refile-goto-last-stored)
          (qk/org-remove-inherited-tag-strings)
          (qk/org-remove-refiling-tag)))

      (add-hook 'org-after-refile-insert-hook 'qk/org-clean-tags)
    #+end_src

**** Series of tags on org-agenda 
    Adding series of tags with the intention of tagging the items for better 
    organization besides the refile file. Adding automated tasks to a tagged item.
    #+begin_src emacs-lisp
      (setq org-tag-alist '((:startgroup . nil)
                            ("@work" . ?w)
                            ("@home" . ?h)
                            (:endgroup . nil)
                            ("literature" . ?n)
                            ("coding" . ?c)
                            ("writing" . ?p)
                            ("emacs" . ?e)
                            ("misc" . ?m)))

      (setq
       org-todo-state-tags-triggers
       (quote (
               ;; Move to cancelled adds the cancelled tag
               ("CANCELLED" ("CANCELLED" . t))
               ;; Move to waiting adds the waiting tag
               ("WAITING" ("WAITING" . t))
               ;; Move to a done state removes waiting/cancelled
               (done ("WAITING") ("CANCELLED"))
               ("DONE" ("WAITING") ("CANCELLED"))
               ;; Move to todo, removes waiting/cancelled
               ("TODO" ("WAITING") ("CANCELLED"))
               )
              )
       )
    #+end_src

**** Org-agenda custom views
    Adding more beautiful org-agenda view with all-icons and better configuration
    of the layout, giving me a lot more information.
    #+begin_src emacs-lisp
      (setq org-deadline-warning-days 3)
      (setq org-agenda-block-separator ?—)
      (setq org-agenda-category-icon-alist
            `(("TODO" (list (all-the-icons-faicon "tasks")) nil nil :ascent center)))
      (setq org-agenda-custom-commands
            '(
              ("d" "Agenda" ((agenda "" ((org-agenda-overriding-header "Today's Schedule:")
                                         (org-agenda-span 'day)
                                         (org-agenda-ndays 1)
                                         (org-agenda-start-on-weekday nil)
                                         (org-agenda-start-day "+0d")
                                         (org-agenda-skip-function '(cond ((equal (file-name-nondirectory (buffer-file-name)) "refile.org") (outline-next-heading) (1- (point)))
                                                                          (t (org-agenda-skip-entry-if 'todo 'done))))
                                         (org-agenda-todo-ignore-deadlines nil)))
                             ;; Project tickle list.
                             (todo "PROJECT" ((org-agenda-overriding-header "Project list:")
                                              (org-tags-match-list-sublevels nil)))
                             ;; Refiling category set file wide in file.
                             (tags "REFILING" ((org-agenda-overriding-header "Tasks to Refile:")
                                               (org-tags-match-list-sublevels nil)))
                             ;; Tasks that are unscheduled
                             (todo "TODO" ((org-agenda-overriding-header "Unscheduled Tasks:")
                                           (org-tags-match-list-sublevels nil)
                                           (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))
                                           ))
                             ;; Tasks that are waiting or someday
                             (todo "WAITING|SOMEDAY" ((org-agenda-overriding-header "Waiting/Someday Tasks:")
                                                      (org-tags-match-list-sublevels nil)))
                             (todo "NOTE" ((org-agenda-overriding-header "Notes:")
                                           (org-tags-match-list-sublevels nil)))
                             (agenda "" ((org-agenda-overriding-header "Upcoming:")
                                         (org-agenda-span 7)
                                         (org-agenda-start-day "+1d")
                                         (org-agenda-start-on-weekday nil)
                                         (org-agenda-skip-function '(cond ((equal (file-name-nondirectory (buffer-file-name)) "refile.org")
                                                                           (outline-next-heading) (1- (point)))
                                                                          (t (org-agenda-skip-entry-if 'todo 'done))
                                                                          ))
                                         ;; I should set this next one to true, so that deadlines are ignored...?
                                         (org-agenda-todo-ignore-deadlines nil))))))

            ;; If an item has a (near) deadline, and is scheduled, only show the deadline.
            org-agenda-skip-scheduled-if-deadline-is-shown t)
    #+end_src

**** Org-agenda keybindings
     Adding custom agenda commands, with the intention of making the refiling and
     tagging workflow a bit faster, as C-c C-w might be cumbersome to write in agenda-view.
     #+begin_src emacs-lisp
       (add-hook 'org-agenda-mode-hook
                 (lambda ()
                   (local-set-key (kbd "r") 'org-agenda-refile)))
     #+end_src

*** Org source blocks
    Tabs on org-mode source blocks try to find the language added.
    If for some reason the language on the source tag doesn't exist
    add 4 spaces.
    #+begin_src emacs-lisp
      (use-package org
        :hook
        (org-tab-first . 
                       (lambda ()
                         (when (org-in-src-block-p t)
                           (let* ((elt (org-element-at-point))
                                  (lang (intern (org-element-property :language elt)))
                                  (langs org-babel-load-languages))
                             (unless (alist-get lang langs)
                               (indent-to 4))))))
        :general
        (minor-mode-definer
         :keymaps 'org-src-mode
         "f" 'org-edit-src-exit
         "c" 'org-edit-src-abort))
    #+end_src

    Remove the annoying warnings when you compile a source block. 
    #+begin_src emacs-lisp
      (use-package ob
        :custom (org-confirm-babel-evaluate nil))

      (use-package ob-ledger
        :commands (org-babel-execute:ledger))
    #+end_src

*** Archiving of files
*** Extension packages
***** Hide properties
      The V2 version of org-roam adds properties to the files, which are then used to query and index the files. Using this org-mode native sintax (instead of buffer properties), a higher performance and consistency is achieved.
      #+begin_src emacs-lisp
        (defun sc/org-hide-properties ()
          "Hide all org-mode headline property drawers in buffer. Could be slow if it has a lot of overlays."
          (interactive)
          (save-excursion
            (goto-char (point-min))
            (while (re-search-forward
                    "^ *:properties:\n\\( *:.+?:.*\n\\)+ *:end:\n" nil t)
              (let ((ov_this (make-overlay (match-beginning 0) (match-end 0))))
                (overlay-put ov_this 'display "")
                (overlay-put ov_this 'hidden-prop-drawer t))))
          (put 'org-toggle-properties-hide-state 'state 'hidden))

        (defun sc/org-show-properties ()
          "Show all org-mode property drawers hidden by org-hide-properties."
          (interactive)
          (remove-overlays (point-min) (point-max) 'hidden-prop-drawer t)
          (put 'org-toggle-properties-hide-state 'state 'shown))

        (defun sc/org-toggle-properties ()
          "Toggle visibility of property drawers."
          (interactive)
          (if (eq (get 'org-toggle-properties-hide-state 'state) 'hidden)
              (sc/org-show-properties)
            (sc/org-hide-properties)))
      #+end_src

***** Hooks
      Adding the execution of certain functions when the org-roam-file-setup-hook
      is run, for example, adding spelling correction functionality.
      #+begin_src emacs-lisp
        (add-hook 'org-roam-file-setup-hook (lambda ()
                                              (flyspell-mode t)
                                              (sc/org-hide-properties)))

        (add-hook 'org-roam-find-file-hook (lambda ()
                                             (sc/org-hide-properties)))
      #+end_src

** Version control
*** Symlinks
    As part of this =dot_files= repo, my configuration philosofy uses
    symlinks to control the files within the repo but still benefit from
    the modifying on only individual files, instead of copying and pasting.
    The =vc= emacs package always asks whether I intend to follow the links
    that are git-controlled, obviously yes.

    #+begin_src emacs-lisp
      (setq vc-follow-symlinks t)
    #+end_src

*** Ediff
    Provides a convenient way of simultaneous browsing through the differences between a pair (or a triple) of files or buffers. Nevertheless, it needs to be configured to remove some of the defaults that are horrible. We will remove the frame that ediff creates, opting for using a window with options if needed. We might even change the behaviour to use a transient command.
    #+begin_src emacs-lisp
      (use-package ediff
        :commands ediff
        :custom
        (ediff-window-setup-function 'ediff-setup-windows-plain)
        (ediff-split-window-function (if (> (frame-width) 150)
                                         'split-window-horizontally
                                       'split-window-vertically))
        (ediff-diff-options "-w"))
    #+end_src

*** Smerge-mode
    =smerge-mode= is a minor mode included in Emacs that provides merging functionality. There has been defined multiple funcions to navigate and act upon changes in files. You are able to use ediff-like functionality to move around and make the changes that you need. The following configuration provides the automatic activation when a merge conflict is detected, a.k.a, when the buffer has multiple "<" in the same line.
    #+begin_src emacs-lisp
      (defun modi/enable-smerge-maybe ()
        "Auto-enable `smerge-mode' when merge conflict is detected."
        (save-excursion
          (goto-char (point-min))
          (when (re-search-forward "^<<<<<<< " nil :noerror)
            (smerge-mode 1))))

      (use-package smerge-mode
        :hook (find-file . modi/enable-smerge-maybe)
        :config
        (defhydra hydra-smerge (:color pink
                                       :hint nil
                                       :pre (smerge-mode 1)
                                       ;; Disable `smerge-mode' when quitting hydra if
                                       ;; no merge conflicts remain.
                                       :post (smerge-auto-leave))
          "
      ^Move^       ^Keep^               ^Diff^                 ^Other^
      ^^-----------^^-------------------^^---------------------^^-------
      _n_ext       _b_ase               _<_: upper/base        _C_ombine
      _p_rev       _u_pper              _=_: upper/lower       _r_esolve
      ^^           _l_ower              _>_: base/lower        _k_ill current
      ^^           _a_ll                _R_efine
      ^^           _RET_: current       _E_diff
      "
          ("n" smerge-next)
          ("p" smerge-prev)
          ("b" smerge-keep-base)
          ("u" smerge-keep-mine)
          ("l" smerge-keep-other)
          ("a" smerge-keep-all)
          ("RET" smerge-keep-current)
          ("\C-m" smerge-keep-current)
          ("<" smerge-diff-base-mine)
          ("=" smerge-diff-mine-other)
          (">" smerge-diff-base-other)
          ("R" smerge-refine)
          ("E" smerge-ediff)
          ("C" smerge-combine-with-next)
          ("r" smerge-resolve)
          ("k" smerge-kill-current)
          ("q" nil "cancel" :color blue)))
    #+end_src

*** Magit
    Obviously [[https://magit.vc/][Magit]].
    #+begin_src emacs-lisp
      (use-package magit
        :straight t
        :bind ("C-x g" . magit-status)
        :hook
        (git-commit-mode . (lambda ()
                             (set-fill-column 72)))
        (magit-status-mode . (lambda ()
                           (linum-mode -1)
                           (display-line-numbers-mode -1)))
        :general
        (minor-mode-definer
          :keymaps 'git-commit-mode
          "f" 'with-editor-finish
          "c" 'with-editor-cancel)
        :custom 
        (git-commit-summary-max-length 50)
        (magit-diff-hide-trailing-cr-characters t))
    #+end_src

*** Transient
    Transient is the way that Magit recommended for setting keybindings, avoiding the clutter that usually forms when trying to get into complex keybindings with [[*Which key][Which key]]. You have different types of transients: suffix-commands, infix-commands and prefix-commands. The documentation is not really easy to understand, but I modified a help-transient that I found online to fit my needs.
    #+begin_src emacs-lisp
      (use-package transient
        :straight t
        :commands transient-define-prefix
        :bind (:map transient-base-map
                    ("<escape>" . transient-quit-one)))
    #+end_src
    
** Project management: Projectile
   #+begin_src emacs-lisp
     (defvar qk/fd-command "fdfind")
     (if (or (eq window-system 'ns)
             (eq window-system 'mac))
         (setq qk/fd-command "fd"))

     (use-package projectile
       :straight t
       :custom
       (projectile-generic-command (concat qk/fd-command " . -0 --type f --color=never"))
       (projectile-project-search-path '("~/Documents/"))
       :general
       (+general-global-project
         "!" '(projectile-run-shell-command-in-root :which-key "shell-command")
         "&" '(projectile-run-async-shell-command-in-root :which-key "async shell-command")
         "d" 'projectile-find-dir
         "D" 'projectile-dired
         "k" 'projectile-kill-buffers
         "o" '(projectile-find-file-other-window :which-key "find-other-window"))
       :config
       (add-to-list 'projectile-project-root-files-bottom-up "pubspec.yaml")
       (add-to-list 'projectile-project-root-files-bottom-up "BUILD")
       (projectile-global-mode))
   #+end_src

** Snippets
*** Yasnippet
    #+begin_src emacs-lisp
      (use-package yasnippet
        :straight t
        :hook ((prog-mode org-mode gfm-mode) . yas-minor-mode)
        :config (yas-reload-all))
    #+end_src

*** Better yasnippets for modes.
    #+begin_src emacs-lisp
      (use-package yasnippet-snippets
        :straight t
        :after yasnippet)
    #+end_src

** Corfu
   As I mentioned in the company configuration update. I can't seem to come around using company for its heavy weight obsession. Instead of trying to create a completion API, let Emacs do its work (using =completion-at-point-functions=, which are normally defined by programming modes), improving the performance in the process. 

   Corfu also uses a child-frame, which is one of the star features of Emacs 26. One of the possible user downsides of using Corfu is that at the moment it doesn't support idle-completion, which could be interesting for programming. I personally find that is just a matter of getting used to the new workflow of completing if you need it.

   Another option is to also set up the `TAB' for cycling through the candidates, but I don't find it particularly interesting. I prefer the company convention of using C-n and C-p.
   #+begin_src emacs-lisp
     (use-package corfu
       :straight t
       :bind (:map corfu-map
                   ("M-j" . corfu-next)
                   ("M-k" . corfu-previous))
       :custom
       (corfu-cycle t)
       (corfu-quit-no-match t)
       (corfu-auto t)
       (corfu-auto-delay 0.1)
       (corfu-auto-prefix 1)
       (corfu-commit-predicate nil)
       :init (corfu-global-mode))

     (use-package emacs
       :init
       ;; TAB cycle if there are only few candidates
       (setq completion-cycle-threshold 3)

       ;; Enable indentation+completion using the TAB key.
       ;; `completion-at-point' is often bound to M-TAB.
       (setq tab-always-indent 'complete))
   #+end_src
** Browser
   “EWW”, the Emacs Web Wowser, is a web browser for GNU Emacs.  It can load, parse, and display various web pages using “shr.el”.  However a GNU Emacs with ‘libxml2’ support is required.
   #+begin_src emacs-lisp
     (use-package shr
       :custom
       (shr-use-colors nil)             ; t is bad for accessibility
       (shr-use-fonts nil)              ; t is not for me
       (shr-max-image-proportion 0.6)
       (shr-image-animate nil)          ; No GIFs, thank you!
       (shr-width nil)                  ; check `prot-eww-readable'
       (shr-discard-aria-hidden t)
       (shr-cookie-policy nil))

     (use-package eww
       :custom
       (eww-restore-desktop t)
       (eww-desktop-remove-duplicates t)
       (eww-header-line-format nil)
       (eww-download-directory (expand-file-name "~/Documents/eww-downloads"))
       (eww-suggest-uris
             '(eww-links-at-point
               thing-at-point-url-at-point))
       (eww-bookmarks-directory (locate-user-emacs-file "eww-bookmarks/"))
       (eww-history-limit 150)
       (eww-use-external-browser-for-content-type
             "\\`\\(video/\\|audio\\)") ; On GNU/Linux check your mimeapps.list
       (eww-browse-url-new-window-is-tab nil)
       (eww-form-checkbox-selected-symbol "[X]")
       (eww-form-checkbox-symbol "[ ]")
       (eww-retrieve-command nil)
       :general
       (+general-global-applications
         "s" 'eww))
   #+end_src

** Programming
*** Tree-sitter-mode
    Tree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source file and efficiently update the syntax tree as the source file is edited. It could be the next generation of sintax parsers, as it has been really accepted by the community and the Github's Atom team has been working on implementing a ton of languages.

    Even though support has been scarce for the last months, the =emacs-tree-sitter= package now supports most of the most I work with, making the experience snappier, specially with big buffers. It doesn't really hurt to try, considering the sintax-highlighting already provided by =font-lock-mode=, which is not specially fast (it is regex based).

    With the following documenation, tree-sitter-hl-mode will be enabled on all supported major modes, and you will be start to benefit from incremental parsing.
    #+begin_src emacs-lisp
      (use-package tree-sitter
        :straight t
        :hook (tree-sitter-after-on . tree-sitter-hl-mode)
        :config
        (straight-use-package 'tree-sitter-langs)
        :init (global-tree-sitter-mode))
    #+end_src
